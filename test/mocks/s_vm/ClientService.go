// Code generated by mockery v2.51.0. DO NOT EDIT.

package s_vm

import (
	clients_vm "github.com/metal-stack/ontap-go/api/client/s_vm"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// SvmCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmCollectionGet(params *clients_vm.SvmCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmCollectionGet")
	}

	var r0 *clients_vm.SvmCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmCreate(params *clients_vm.SvmCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmCreateCreated, *clients_vm.SvmCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmCreate")
	}

	var r0 *clients_vm.SvmCreateCreated
	var r1 *clients_vm.SvmCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmCreateCreated, *clients_vm.SvmCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmDelete(params *clients_vm.SvmDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmDeleteOK, *clients_vm.SvmDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmDelete")
	}

	var r0 *clients_vm.SvmDeleteOK
	var r1 *clients_vm.SvmDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmDeleteOK, *clients_vm.SvmDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmGet(params *clients_vm.SvmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmGet")
	}

	var r0 *clients_vm.SvmGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmMigrationCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationCollectionGet(params *clients_vm.SvmMigrationCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationCollectionGet")
	}

	var r0 *clients_vm.SvmMigrationCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmMigrationCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationCreate(params *clients_vm.SvmMigrationCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationCreateCreated, *clients_vm.SvmMigrationCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationCreate")
	}

	var r0 *clients_vm.SvmMigrationCreateCreated
	var r1 *clients_vm.SvmMigrationCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationCreateCreated, *clients_vm.SvmMigrationCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmMigrationCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmMigrationCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmMigrationDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationDelete(params *clients_vm.SvmMigrationDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationDeleteOK, *clients_vm.SvmMigrationDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationDelete")
	}

	var r0 *clients_vm.SvmMigrationDeleteOK
	var r1 *clients_vm.SvmMigrationDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationDeleteOK, *clients_vm.SvmMigrationDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmMigrationDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmMigrationDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmMigrationGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationGet(params *clients_vm.SvmMigrationGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationGet")
	}

	var r0 *clients_vm.SvmMigrationGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmMigrationModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationModify(params *clients_vm.SvmMigrationModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationModifyOK, *clients_vm.SvmMigrationModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationModify")
	}

	var r0 *clients_vm.SvmMigrationModifyOK
	var r1 *clients_vm.SvmMigrationModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationModifyOK, *clients_vm.SvmMigrationModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmMigrationModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmMigrationModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmMigrationVolumeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationVolumeCollectionGet(params *clients_vm.SvmMigrationVolumeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationVolumeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationVolumeCollectionGet")
	}

	var r0 *clients_vm.SvmMigrationVolumeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationVolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationVolumeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationVolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationVolumeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationVolumeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationVolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmMigrationVolumeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmMigrationVolumeGet(params *clients_vm.SvmMigrationVolumeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmMigrationVolumeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmMigrationVolumeGet")
	}

	var r0 *clients_vm.SvmMigrationVolumeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationVolumeGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmMigrationVolumeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmMigrationVolumeGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmMigrationVolumeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmMigrationVolumeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmMigrationVolumeGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmModify(params *clients_vm.SvmModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmModifyOK, *clients_vm.SvmModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmModify")
	}

	var r0 *clients_vm.SvmModifyOK
	var r1 *clients_vm.SvmModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmModifyOK, *clients_vm.SvmModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmPeerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerCollectionGet(params *clients_vm.SvmPeerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerCollectionGet")
	}

	var r0 *clients_vm.SvmPeerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerCreate(params *clients_vm.SvmPeerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerCreateCreated, *clients_vm.SvmPeerCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerCreate")
	}

	var r0 *clients_vm.SvmPeerCreateCreated
	var r1 *clients_vm.SvmPeerCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerCreateCreated, *clients_vm.SvmPeerCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmPeerCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmPeerCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmPeerDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerDelete(params *clients_vm.SvmPeerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerDeleteOK, *clients_vm.SvmPeerDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerDelete")
	}

	var r0 *clients_vm.SvmPeerDeleteOK
	var r1 *clients_vm.SvmPeerDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerDeleteOK, *clients_vm.SvmPeerDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmPeerDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmPeerInstanceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerInstanceGet(params *clients_vm.SvmPeerInstanceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerInstanceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerInstanceGet")
	}

	var r0 *clients_vm.SvmPeerInstanceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerInstanceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerInstanceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerInstanceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerModify(params *clients_vm.SvmPeerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerModifyOK, *clients_vm.SvmPeerModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerModify")
	}

	var r0 *clients_vm.SvmPeerModifyOK
	var r1 *clients_vm.SvmPeerModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerModifyOK, *clients_vm.SvmPeerModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.SvmPeerModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.SvmPeerModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SvmPeerPermissionCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerPermissionCollectionGet(params *clients_vm.SvmPeerPermissionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerPermissionCollectionGet")
	}

	var r0 *clients_vm.SvmPeerPermissionCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerPermissionCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerPermissionCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerPermissionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerPermissionCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerPermissionCreate(params *clients_vm.SvmPeerPermissionCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerPermissionCreate")
	}

	var r0 *clients_vm.SvmPeerPermissionCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerPermissionCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerPermissionCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerPermissionCreateParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerPermissionDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerPermissionDelete(params *clients_vm.SvmPeerPermissionDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerPermissionDelete")
	}

	var r0 *clients_vm.SvmPeerPermissionDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerPermissionDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerPermissionDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerPermissionDeleteParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerPermissionInstanceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerPermissionInstanceGet(params *clients_vm.SvmPeerPermissionInstanceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionInstanceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerPermissionInstanceGet")
	}

	var r0 *clients_vm.SvmPeerPermissionInstanceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionInstanceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerPermissionInstanceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerPermissionInstanceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerPermissionInstanceGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmPeerPermissionModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmPeerPermissionModify(params *clients_vm.SvmPeerPermissionModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmPeerPermissionModify")
	}

	var r0 *clients_vm.SvmPeerPermissionModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.SvmPeerPermissionModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.SvmPeerPermissionModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.SvmPeerPermissionModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.SvmPeerPermissionModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.SvmPeerPermissionModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsSvmClientCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsSvmClientCollectionGet(params *clients_vm.TopMetricsSvmClientCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmClientCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsSvmClientCollectionGet")
	}

	var r0 *clients_vm.TopMetricsSvmClientCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmClientCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.TopMetricsSvmClientCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.TopMetricsSvmClientCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.TopMetricsSvmClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsSvmDirectoryCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsSvmDirectoryCollectionGet(params *clients_vm.TopMetricsSvmDirectoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmDirectoryCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsSvmDirectoryCollectionGet")
	}

	var r0 *clients_vm.TopMetricsSvmDirectoryCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmDirectoryCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.TopMetricsSvmDirectoryCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.TopMetricsSvmDirectoryCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.TopMetricsSvmDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsSvmFileCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsSvmFileCollectionGet(params *clients_vm.TopMetricsSvmFileCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmFileCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsSvmFileCollectionGet")
	}

	var r0 *clients_vm.TopMetricsSvmFileCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmFileCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.TopMetricsSvmFileCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.TopMetricsSvmFileCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.TopMetricsSvmFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsSvmUserCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsSvmUserCollectionGet(params *clients_vm.TopMetricsSvmUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmUserCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsSvmUserCollectionGet")
	}

	var r0 *clients_vm.TopMetricsSvmUserCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.TopMetricsSvmUserCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.TopMetricsSvmUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.TopMetricsSvmUserCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.TopMetricsSvmUserCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.TopMetricsSvmUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebSvmGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) WebSvmGet(params *clients_vm.WebSvmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.WebSvmGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebSvmGet")
	}

	var r0 *clients_vm.WebSvmGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clients_vm.WebSvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.WebSvmGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.WebSvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.WebSvmGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.WebSvmGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.WebSvmGetParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebSvmModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) WebSvmModify(params *clients_vm.WebSvmModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clients_vm.ClientOption) (*clients_vm.WebSvmModifyOK, *clients_vm.WebSvmModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebSvmModify")
	}

	var r0 *clients_vm.WebSvmModifyOK
	var r1 *clients_vm.WebSvmModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clients_vm.WebSvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) (*clients_vm.WebSvmModifyOK, *clients_vm.WebSvmModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clients_vm.WebSvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.WebSvmModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients_vm.WebSvmModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clients_vm.WebSvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) *clients_vm.WebSvmModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clients_vm.WebSvmModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clients_vm.WebSvmModifyParams, runtime.ClientAuthInfoWriter, ...clients_vm.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
