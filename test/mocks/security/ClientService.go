// Code generated by mockery v2.52.3. DO NOT EDIT.

package security

import (
	clientsecurity "github.com/metal-stack/ontap-go/api/client/security"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// AccountCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountCollectionGet(params *clientsecurity.AccountCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountCollectionGet")
	}

	var r0 *clientsecurity.AccountCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountCreate(params *clientsecurity.AccountCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountCreate")
	}

	var r0 *clientsecurity.AccountCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountDelete(params *clientsecurity.AccountDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountDelete")
	}

	var r0 *clientsecurity.AccountDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountDuoDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountDuoDelete(params *clientsecurity.AccountDuoDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountDuoDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountDuoDelete")
	}

	var r0 *clientsecurity.AccountDuoDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDuoDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountDuoDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDuoDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountDuoDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountDuoDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountDuoDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountDuogroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountDuogroupDelete(params *clientsecurity.AccountDuogroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountDuogroupDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountDuogroupDelete")
	}

	var r0 *clientsecurity.AccountDuogroupDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDuogroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountDuogroupDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountDuogroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountDuogroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountDuogroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountDuogroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountGet(params *clientsecurity.AccountGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountGet")
	}

	var r0 *clientsecurity.AccountGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountModify(params *clientsecurity.AccountModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountModify")
	}

	var r0 *clientsecurity.AccountModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountPasswordCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountPasswordCreate(params *clientsecurity.AccountPasswordCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountPasswordCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountPasswordCreate")
	}

	var r0 *clientsecurity.AccountPasswordCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountPasswordCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountPasswordCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountPasswordCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountPasswordCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountPasswordCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountPasswordCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountPublickeyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountPublickeyDelete(params *clientsecurity.AccountPublickeyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountPublickeyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountPublickeyDelete")
	}

	var r0 *clientsecurity.AccountPublickeyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountPublickeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountPublickeyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountPublickeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountPublickeyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountPublickeyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountPublickeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountTotpDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AccountTotpDelete(params *clientsecurity.AccountTotpDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AccountTotpDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountTotpDelete")
	}

	var r0 *clientsecurity.AccountTotpDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountTotpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AccountTotpDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AccountTotpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AccountTotpDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AccountTotpDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AccountTotpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AntiRansomwareSuspectCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AntiRansomwareSuspectCollectionGet(params *clientsecurity.AntiRansomwareSuspectCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AntiRansomwareSuspectCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AntiRansomwareSuspectCollectionGet")
	}

	var r0 *clientsecurity.AntiRansomwareSuspectCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AntiRansomwareSuspectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AntiRansomwareSuspectCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AntiRansomwareSuspectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AntiRansomwareSuspectCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AntiRansomwareSuspectCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AntiRansomwareSuspectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AntiRansomwareSuspectDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AntiRansomwareSuspectDelete(params *clientsecurity.AntiRansomwareSuspectDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AntiRansomwareSuspectDeleteOK, *clientsecurity.AntiRansomwareSuspectDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AntiRansomwareSuspectDelete")
	}

	var r0 *clientsecurity.AntiRansomwareSuspectDeleteOK
	var r1 *clientsecurity.AntiRansomwareSuspectDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AntiRansomwareSuspectDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AntiRansomwareSuspectDeleteOK, *clientsecurity.AntiRansomwareSuspectDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AntiRansomwareSuspectDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AntiRansomwareSuspectDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AntiRansomwareSuspectDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AntiRansomwareSuspectDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AntiRansomwareSuspectDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AntiRansomwareSuspectDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AntiRansomwareSuspectDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AuditLogForwardingGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditLogForwardingGet(params *clientsecurity.AuditLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AuditLogForwardingGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditLogForwardingGet")
	}

	var r0 *clientsecurity.AuditLogForwardingGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AuditLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AuditLogForwardingGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AuditLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AuditLogForwardingGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AuditLogForwardingGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AuditLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwsKmsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsCollectionGet(params *clientsecurity.AwsKmsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsCollectionGet")
	}

	var r0 *clientsecurity.AwsKmsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwsKmsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsCreate(params *clientsecurity.AwsKmsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsCreateCreated, *clientsecurity.AwsKmsCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsCreate")
	}

	var r0 *clientsecurity.AwsKmsCreateCreated
	var r1 *clientsecurity.AwsKmsCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsCreateCreated, *clientsecurity.AwsKmsCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwsKmsDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsDelete(params *clientsecurity.AwsKmsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsDeleteOK, *clientsecurity.AwsKmsDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsDelete")
	}

	var r0 *clientsecurity.AwsKmsDeleteOK
	var r1 *clientsecurity.AwsKmsDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsDeleteOK, *clientsecurity.AwsKmsDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwsKmsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsGet(params *clientsecurity.AwsKmsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsGet")
	}

	var r0 *clientsecurity.AwsKmsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwsKmsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsModify(params *clientsecurity.AwsKmsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsModifyOK, *clientsecurity.AwsKmsModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsModify")
	}

	var r0 *clientsecurity.AwsKmsModifyOK
	var r1 *clientsecurity.AwsKmsModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsModifyOK, *clientsecurity.AwsKmsModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwsKmsRekeyExternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsRekeyExternal(params *clientsecurity.AwsKmsRekeyExternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRekeyExternalCreated, *clientsecurity.AwsKmsRekeyExternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsRekeyExternal")
	}

	var r0 *clientsecurity.AwsKmsRekeyExternalCreated
	var r1 *clientsecurity.AwsKmsRekeyExternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRekeyExternalCreated, *clientsecurity.AwsKmsRekeyExternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRekeyExternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsRekeyExternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRekeyExternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsRekeyExternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwsKmsRekeyInternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsRekeyInternal(params *clientsecurity.AwsKmsRekeyInternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRekeyInternalCreated, *clientsecurity.AwsKmsRekeyInternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsRekeyInternal")
	}

	var r0 *clientsecurity.AwsKmsRekeyInternalCreated
	var r1 *clientsecurity.AwsKmsRekeyInternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRekeyInternalCreated, *clientsecurity.AwsKmsRekeyInternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRekeyInternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsRekeyInternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRekeyInternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsRekeyInternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwsKmsRestore provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AwsKmsRestore(params *clientsecurity.AwsKmsRestoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRestoreCreated, *clientsecurity.AwsKmsRestoreAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AwsKmsRestore")
	}

	var r0 *clientsecurity.AwsKmsRestoreCreated
	var r1 *clientsecurity.AwsKmsRestoreAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AwsKmsRestoreCreated, *clientsecurity.AwsKmsRestoreAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AwsKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRestoreCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AwsKmsRestoreCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AwsKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AwsKmsRestoreAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AwsKmsRestoreAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AwsKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultCollectionGet(params *clientsecurity.AzureKeyVaultCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultCollectionGet")
	}

	var r0 *clientsecurity.AzureKeyVaultCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AzureKeyVaultCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultCreate(params *clientsecurity.AzureKeyVaultCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultCreateCreated, *clientsecurity.AzureKeyVaultCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultCreate")
	}

	var r0 *clientsecurity.AzureKeyVaultCreateCreated
	var r1 *clientsecurity.AzureKeyVaultCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultCreateCreated, *clientsecurity.AzureKeyVaultCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultDelete(params *clientsecurity.AzureKeyVaultDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultDeleteOK, *clientsecurity.AzureKeyVaultDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultDelete")
	}

	var r0 *clientsecurity.AzureKeyVaultDeleteOK
	var r1 *clientsecurity.AzureKeyVaultDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultDeleteOK, *clientsecurity.AzureKeyVaultDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultGet(params *clientsecurity.AzureKeyVaultGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultGet")
	}

	var r0 *clientsecurity.AzureKeyVaultGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AzureKeyVaultModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultModify(params *clientsecurity.AzureKeyVaultModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultModifyOK, *clientsecurity.AzureKeyVaultModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultModify")
	}

	var r0 *clientsecurity.AzureKeyVaultModifyOK
	var r1 *clientsecurity.AzureKeyVaultModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultModifyOK, *clientsecurity.AzureKeyVaultModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultRekeyExternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultRekeyExternal(params *clientsecurity.AzureKeyVaultRekeyExternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRekeyExternalCreated, *clientsecurity.AzureKeyVaultRekeyExternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultRekeyExternal")
	}

	var r0 *clientsecurity.AzureKeyVaultRekeyExternalCreated
	var r1 *clientsecurity.AzureKeyVaultRekeyExternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRekeyExternalCreated, *clientsecurity.AzureKeyVaultRekeyExternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRekeyExternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultRekeyExternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRekeyExternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultRekeyExternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultRekeyInternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultRekeyInternal(params *clientsecurity.AzureKeyVaultRekeyInternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRekeyInternalCreated, *clientsecurity.AzureKeyVaultRekeyInternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultRekeyInternal")
	}

	var r0 *clientsecurity.AzureKeyVaultRekeyInternalCreated
	var r1 *clientsecurity.AzureKeyVaultRekeyInternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRekeyInternalCreated, *clientsecurity.AzureKeyVaultRekeyInternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRekeyInternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultRekeyInternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRekeyInternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultRekeyInternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AzureKeyVaultRestore provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AzureKeyVaultRestore(params *clientsecurity.AzureKeyVaultRestoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRestoreCreated, *clientsecurity.AzureKeyVaultRestoreAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AzureKeyVaultRestore")
	}

	var r0 *clientsecurity.AzureKeyVaultRestoreCreated
	var r1 *clientsecurity.AzureKeyVaultRestoreAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.AzureKeyVaultRestoreCreated, *clientsecurity.AzureKeyVaultRestoreAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.AzureKeyVaultRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRestoreCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.AzureKeyVaultRestoreCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.AzureKeyVaultRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.AzureKeyVaultRestoreAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.AzureKeyVaultRestoreAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.AzureKeyVaultRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterAccountAdProxyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterAccountAdProxyCreate(params *clientsecurity.ClusterAccountAdProxyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAccountAdProxyCreate")
	}

	var r0 *clientsecurity.ClusterAccountAdProxyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterAccountAdProxyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterAccountAdProxyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterAccountAdProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterAccountAdProxyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterAccountAdProxyDelete(params *clientsecurity.ClusterAccountAdProxyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAccountAdProxyDelete")
	}

	var r0 *clientsecurity.ClusterAccountAdProxyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterAccountAdProxyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterAccountAdProxyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterAccountAdProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterAccountAdProxyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterAccountAdProxyGet(params *clientsecurity.ClusterAccountAdProxyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAccountAdProxyGet")
	}

	var r0 *clientsecurity.ClusterAccountAdProxyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterAccountAdProxyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterAccountAdProxyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterAccountAdProxyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterAccountAdProxyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterAccountAdProxyModify(params *clientsecurity.ClusterAccountAdProxyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAccountAdProxyModify")
	}

	var r0 *clientsecurity.ClusterAccountAdProxyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterAccountAdProxyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterAccountAdProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterAccountAdProxyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterAccountAdProxyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterAccountAdProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterLdapCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterLdapCreate(params *clientsecurity.ClusterLdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLdapCreate")
	}

	var r0 *clientsecurity.ClusterLdapCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterLdapCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterLdapCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterLdapCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterLdapDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterLdapDelete(params *clientsecurity.ClusterLdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLdapDelete")
	}

	var r0 *clientsecurity.ClusterLdapDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterLdapDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterLdapDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterLdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterLdapGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterLdapGet(params *clientsecurity.ClusterLdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLdapGet")
	}

	var r0 *clientsecurity.ClusterLdapGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterLdapGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterLdapGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterLdapGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterLdapModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterLdapModify(params *clientsecurity.ClusterLdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLdapModify")
	}

	var r0 *clientsecurity.ClusterLdapModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterLdapModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterLdapModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterLdapModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterLdapModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterLdapModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNisCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNisCreate(params *clientsecurity.ClusterNisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNisCreate")
	}

	var r0 *clientsecurity.ClusterNisCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterNisCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterNisCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterNisCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNisDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNisDelete(params *clientsecurity.ClusterNisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNisDelete")
	}

	var r0 *clientsecurity.ClusterNisDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterNisDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterNisDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterNisDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNisGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNisGet(params *clientsecurity.ClusterNisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNisGet")
	}

	var r0 *clientsecurity.ClusterNisGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterNisGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterNisGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterNisGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNisModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNisModify(params *clientsecurity.ClusterNisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNisModify")
	}

	var r0 *clientsecurity.ClusterNisModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.ClusterNisModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.ClusterNisModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.ClusterNisModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.ClusterNisModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.ClusterNisModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCertificateSigningRequest provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateCertificateSigningRequest(params *clientsecurity.CreateCertificateSigningRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.CreateCertificateSigningRequestOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCertificateSigningRequest")
	}

	var r0 *clientsecurity.CreateCertificateSigningRequestOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.CreateCertificateSigningRequestParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.CreateCertificateSigningRequestOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.CreateCertificateSigningRequestParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.CreateCertificateSigningRequestOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.CreateCertificateSigningRequestOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.CreateCertificateSigningRequestParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuoCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuoCollectionGet(params *clientsecurity.DuoCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuoCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuoCollectionGet")
	}

	var r0 *clientsecurity.DuoCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuoCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuoCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuoCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuoCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuoCreate(params *clientsecurity.DuoCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuoCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuoCreate")
	}

	var r0 *clientsecurity.DuoCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuoCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuoCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuoCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuoCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuoGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuoGet(params *clientsecurity.DuoGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuoGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuoGet")
	}

	var r0 *clientsecurity.DuoGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuoGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuoGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuoGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuoGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuoModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuoModify(params *clientsecurity.DuoModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuoModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuoModify")
	}

	var r0 *clientsecurity.DuoModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuoModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuoModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuoModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuoModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuoModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuogroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuogroupCollectionGet(params *clientsecurity.DuogroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuogroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuogroupCollectionGet")
	}

	var r0 *clientsecurity.DuogroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuogroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuogroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuogroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuogroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuogroupCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuogroupCreate(params *clientsecurity.DuogroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuogroupCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuogroupCreate")
	}

	var r0 *clientsecurity.DuogroupCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuogroupCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuogroupCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuogroupCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuogroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuogroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuogroupGet(params *clientsecurity.DuogroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuogroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuogroupGet")
	}

	var r0 *clientsecurity.DuogroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuogroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuogroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuogroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuogroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DuogroupModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DuogroupModify(params *clientsecurity.DuogroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.DuogroupModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DuogroupModify")
	}

	var r0 *clientsecurity.DuogroupModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.DuogroupModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.DuogroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.DuogroupModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.DuogroupModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.DuogroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GcpKmsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsCollectionGet(params *clientsecurity.GcpKmsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsCollectionGet")
	}

	var r0 *clientsecurity.GcpKmsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GcpKmsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsCreate(params *clientsecurity.GcpKmsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsCreateCreated, *clientsecurity.GcpKmsCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsCreate")
	}

	var r0 *clientsecurity.GcpKmsCreateCreated
	var r1 *clientsecurity.GcpKmsCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsCreateCreated, *clientsecurity.GcpKmsCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GcpKmsDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsDelete(params *clientsecurity.GcpKmsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsDeleteOK, *clientsecurity.GcpKmsDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsDelete")
	}

	var r0 *clientsecurity.GcpKmsDeleteOK
	var r1 *clientsecurity.GcpKmsDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsDeleteOK, *clientsecurity.GcpKmsDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GcpKmsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsGet(params *clientsecurity.GcpKmsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsGet")
	}

	var r0 *clientsecurity.GcpKmsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GcpKmsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsModify(params *clientsecurity.GcpKmsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsModifyOK, *clientsecurity.GcpKmsModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsModify")
	}

	var r0 *clientsecurity.GcpKmsModifyOK
	var r1 *clientsecurity.GcpKmsModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsModifyOK, *clientsecurity.GcpKmsModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GcpKmsRekeyExternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsRekeyExternal(params *clientsecurity.GcpKmsRekeyExternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRekeyExternalCreated, *clientsecurity.GcpKmsRekeyExternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsRekeyExternal")
	}

	var r0 *clientsecurity.GcpKmsRekeyExternalCreated
	var r1 *clientsecurity.GcpKmsRekeyExternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRekeyExternalCreated, *clientsecurity.GcpKmsRekeyExternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRekeyExternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsRekeyExternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRekeyExternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsRekeyExternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsRekeyExternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GcpKmsRekeyInternal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsRekeyInternal(params *clientsecurity.GcpKmsRekeyInternalParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRekeyInternalCreated, *clientsecurity.GcpKmsRekeyInternalAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsRekeyInternal")
	}

	var r0 *clientsecurity.GcpKmsRekeyInternalCreated
	var r1 *clientsecurity.GcpKmsRekeyInternalAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRekeyInternalCreated, *clientsecurity.GcpKmsRekeyInternalAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRekeyInternalCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsRekeyInternalCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRekeyInternalAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsRekeyInternalAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsRekeyInternalParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GcpKmsRestore provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GcpKmsRestore(params *clientsecurity.GcpKmsRestoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRestoreCreated, *clientsecurity.GcpKmsRestoreAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GcpKmsRestore")
	}

	var r0 *clientsecurity.GcpKmsRestoreCreated
	var r1 *clientsecurity.GcpKmsRestoreAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.GcpKmsRestoreCreated, *clientsecurity.GcpKmsRestoreAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.GcpKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRestoreCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.GcpKmsRestoreCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.GcpKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.GcpKmsRestoreAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.GcpKmsRestoreAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.GcpKmsRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IpsecCaCertificateCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecCaCertificateCollectionGet(params *clientsecurity.IpsecCaCertificateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecCaCertificateCollectionGet")
	}

	var r0 *clientsecurity.IpsecCaCertificateCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecCaCertificateCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecCaCertificateCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecCaCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecCaCertificateCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecCaCertificateCreate(params *clientsecurity.IpsecCaCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecCaCertificateCreate")
	}

	var r0 *clientsecurity.IpsecCaCertificateCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecCaCertificateCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecCaCertificateCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecCaCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecCaCertificateDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecCaCertificateDelete(params *clientsecurity.IpsecCaCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecCaCertificateDelete")
	}

	var r0 *clientsecurity.IpsecCaCertificateDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecCaCertificateDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecCaCertificateDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecCaCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecCaCertificateGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecCaCertificateGet(params *clientsecurity.IpsecCaCertificateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecCaCertificateGet")
	}

	var r0 *clientsecurity.IpsecCaCertificateGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecCaCertificateGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecCaCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecCaCertificateGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecCaCertificateGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecCaCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecGet(params *clientsecurity.IpsecGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecGet")
	}

	var r0 *clientsecurity.IpsecGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecModify(params *clientsecurity.IpsecModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecModify")
	}

	var r0 *clientsecurity.IpsecModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecPolicyCollectionGet(params *clientsecurity.IpsecPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecPolicyCollectionGet")
	}

	var r0 *clientsecurity.IpsecPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecPolicyCreate(params *clientsecurity.IpsecPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecPolicyCreate")
	}

	var r0 *clientsecurity.IpsecPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecPolicyDelete(params *clientsecurity.IpsecPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecPolicyDelete")
	}

	var r0 *clientsecurity.IpsecPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecPolicyGet(params *clientsecurity.IpsecPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecPolicyGet")
	}

	var r0 *clientsecurity.IpsecPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpsecPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpsecPolicyModify(params *clientsecurity.IpsecPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpsecPolicyModify")
	}

	var r0 *clientsecurity.IpsecPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.IpsecPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.IpsecPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.IpsecPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.IpsecPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.IpsecPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerAuthKeyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerAuthKeyCollectionGet(params *clientsecurity.KeyManagerAuthKeyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerAuthKeyCollectionGet")
	}

	var r0 *clientsecurity.KeyManagerAuthKeyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerAuthKeyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerAuthKeyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerAuthKeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerAuthKeyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerAuthKeyCreate(params *clientsecurity.KeyManagerAuthKeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerAuthKeyCreate")
	}

	var r0 *clientsecurity.KeyManagerAuthKeyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerAuthKeyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerAuthKeyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerAuthKeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerAuthKeyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerAuthKeyDelete(params *clientsecurity.KeyManagerAuthKeyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerAuthKeyDelete")
	}

	var r0 *clientsecurity.KeyManagerAuthKeyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerAuthKeyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerAuthKeyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerAuthKeyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerAuthKeyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerAuthKeyGet(params *clientsecurity.KeyManagerAuthKeyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerAuthKeyGet")
	}

	var r0 *clientsecurity.KeyManagerAuthKeyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerAuthKeyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerAuthKeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerAuthKeyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerAuthKeyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerAuthKeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerConfigGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerConfigGet(params *clientsecurity.KeyManagerConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerConfigGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerConfigGet")
	}

	var r0 *clientsecurity.KeyManagerConfigGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerConfigGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerConfigGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerConfigGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerConfigModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerConfigModify(params *clientsecurity.KeyManagerConfigModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerConfigModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerConfigModify")
	}

	var r0 *clientsecurity.KeyManagerConfigModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerConfigModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerConfigModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerConfigModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerKeysCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerKeysCollectionGet(params *clientsecurity.KeyManagerKeysCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerKeysCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerKeysCollectionGet")
	}

	var r0 *clientsecurity.KeyManagerKeysCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerKeysCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerKeysCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerKeysCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyManagerKeysGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KeyManagerKeysGet(params *clientsecurity.KeyManagerKeysGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerKeysGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KeyManagerKeysGet")
	}

	var r0 *clientsecurity.KeyManagerKeysGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerKeysGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.KeyManagerKeysGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.KeyManagerKeysGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.KeyManagerKeysGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.KeyManagerKeysGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.KeyManagerKeysGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginMessagesCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LoginMessagesCollectionGet(params *clientsecurity.LoginMessagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginMessagesCollectionGet")
	}

	var r0 *clientsecurity.LoginMessagesCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.LoginMessagesCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.LoginMessagesCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.LoginMessagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginMessagesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LoginMessagesGet(params *clientsecurity.LoginMessagesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginMessagesGet")
	}

	var r0 *clientsecurity.LoginMessagesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.LoginMessagesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.LoginMessagesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.LoginMessagesGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginMessagesModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LoginMessagesModify(params *clientsecurity.LoginMessagesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginMessagesModify")
	}

	var r0 *clientsecurity.LoginMessagesModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.LoginMessagesModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.LoginMessagesModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.LoginMessagesModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.LoginMessagesModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.LoginMessagesModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyApprovalGroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyApprovalGroupCollectionGet(params *clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyApprovalGroupCollectionGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyApprovalGroupCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyApprovalGroupCreate(params *clientsecurity.MultiAdminVerifyApprovalGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyApprovalGroupCreate")
	}

	var r0 *clientsecurity.MultiAdminVerifyApprovalGroupCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyApprovalGroupCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyApprovalGroupCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyApprovalGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyApprovalGroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyApprovalGroupDelete(params *clientsecurity.MultiAdminVerifyApprovalGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyApprovalGroupDelete")
	}

	var r0 *clientsecurity.MultiAdminVerifyApprovalGroupDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyApprovalGroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyApprovalGroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyApprovalGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyApprovalGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyApprovalGroupGet(params *clientsecurity.MultiAdminVerifyApprovalGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyApprovalGroupGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyApprovalGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyApprovalGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyApprovalGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyApprovalGroupGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyApprovalGroupModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyApprovalGroupModify(params *clientsecurity.MultiAdminVerifyApprovalGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyApprovalGroupModify")
	}

	var r0 *clientsecurity.MultiAdminVerifyApprovalGroupModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyApprovalGroupModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyApprovalGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyApprovalGroupModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyApprovalGroupModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyApprovalGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyConfigGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyConfigGet(params *clientsecurity.MultiAdminVerifyConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyConfigGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyConfigGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyConfigGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyConfigGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyConfigGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyConfigGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyConfigModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyConfigModify(params *clientsecurity.MultiAdminVerifyConfigModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyConfigModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyConfigModify")
	}

	var r0 *clientsecurity.MultiAdminVerifyConfigModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyConfigModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyConfigModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyConfigModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRequestCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRequestCollectionGet(params *clientsecurity.MultiAdminVerifyRequestCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRequestCollectionGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyRequestCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRequestCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRequestCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRequestCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRequestCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRequestCreate(params *clientsecurity.MultiAdminVerifyRequestCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRequestCreate")
	}

	var r0 *clientsecurity.MultiAdminVerifyRequestCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRequestCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRequestCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRequestCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRequestDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRequestDelete(params *clientsecurity.MultiAdminVerifyRequestDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRequestDelete")
	}

	var r0 *clientsecurity.MultiAdminVerifyRequestDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRequestDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRequestDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRequestDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRequestGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRequestGet(params *clientsecurity.MultiAdminVerifyRequestGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRequestGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyRequestGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRequestGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRequestGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRequestGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRequestModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRequestModify(params *clientsecurity.MultiAdminVerifyRequestModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRequestModify")
	}

	var r0 *clientsecurity.MultiAdminVerifyRequestModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRequestModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRequestModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRequestModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRequestModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRequestModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRuleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRuleCollectionGet(params *clientsecurity.MultiAdminVerifyRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRuleCollectionGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyRuleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRuleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRuleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRuleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRuleCreate(params *clientsecurity.MultiAdminVerifyRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRuleCreate")
	}

	var r0 *clientsecurity.MultiAdminVerifyRuleCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRuleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRuleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRuleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRuleDelete(params *clientsecurity.MultiAdminVerifyRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRuleDelete")
	}

	var r0 *clientsecurity.MultiAdminVerifyRuleDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRuleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRuleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRuleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRuleGet(params *clientsecurity.MultiAdminVerifyRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRuleGet")
	}

	var r0 *clientsecurity.MultiAdminVerifyRuleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRuleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRuleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRuleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MultiAdminVerifyRuleModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MultiAdminVerifyRuleModify(params *clientsecurity.MultiAdminVerifyRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiAdminVerifyRuleModify")
	}

	var r0 *clientsecurity.MultiAdminVerifyRuleModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.MultiAdminVerifyRuleModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.MultiAdminVerifyRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.MultiAdminVerifyRuleModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.MultiAdminVerifyRuleModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.MultiAdminVerifyRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublickeyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PublickeyCollectionGet(params *clientsecurity.PublickeyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.PublickeyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublickeyCollectionGet")
	}

	var r0 *clientsecurity.PublickeyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.PublickeyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.PublickeyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.PublickeyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.PublickeyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublickeyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PublickeyCreate(params *clientsecurity.PublickeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.PublickeyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublickeyCreate")
	}

	var r0 *clientsecurity.PublickeyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.PublickeyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.PublickeyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.PublickeyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.PublickeyCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublickeyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PublickeyGet(params *clientsecurity.PublickeyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.PublickeyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublickeyGet")
	}

	var r0 *clientsecurity.PublickeyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.PublickeyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.PublickeyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.PublickeyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.PublickeyGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublickeyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PublickeyModify(params *clientsecurity.PublickeyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.PublickeyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublickeyModify")
	}

	var r0 *clientsecurity.PublickeyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.PublickeyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.PublickeyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.PublickeyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.PublickeyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.PublickeyModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RoleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RoleCollectionGet(params *clientsecurity.RoleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RoleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RoleCollectionGet")
	}

	var r0 *clientsecurity.RoleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RoleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RoleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RoleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RoleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RoleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RoleCreate(params *clientsecurity.RoleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RoleCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RoleCreate")
	}

	var r0 *clientsecurity.RoleCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RoleCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RoleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RoleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RoleCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RoleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RoleDelete(params *clientsecurity.RoleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RoleDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RoleDelete")
	}

	var r0 *clientsecurity.RoleDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RoleDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RoleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RoleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RoleDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RoleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RoleGet(params *clientsecurity.RoleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RoleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RoleGet")
	}

	var r0 *clientsecurity.RoleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RoleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RoleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RoleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RoleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RoleGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RolePrivilegeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RolePrivilegeCollectionGet(params *clientsecurity.RolePrivilegeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RolePrivilegeCollectionGet")
	}

	var r0 *clientsecurity.RolePrivilegeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RolePrivilegeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RolePrivilegeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RolePrivilegeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RolePrivilegeCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RolePrivilegeCreate(params *clientsecurity.RolePrivilegeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RolePrivilegeCreate")
	}

	var r0 *clientsecurity.RolePrivilegeCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RolePrivilegeCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RolePrivilegeCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RolePrivilegeCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RolePrivilegeDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RolePrivilegeDelete(params *clientsecurity.RolePrivilegeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RolePrivilegeDelete")
	}

	var r0 *clientsecurity.RolePrivilegeDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RolePrivilegeDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RolePrivilegeDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RolePrivilegeDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RolePrivilegeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RolePrivilegeGet(params *clientsecurity.RolePrivilegeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RolePrivilegeGet")
	}

	var r0 *clientsecurity.RolePrivilegeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RolePrivilegeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RolePrivilegeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RolePrivilegeGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RolePrivilegeModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RolePrivilegeModify(params *clientsecurity.RolePrivilegeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RolePrivilegeModify")
	}

	var r0 *clientsecurity.RolePrivilegeModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.RolePrivilegeModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.RolePrivilegeModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.RolePrivilegeModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.RolePrivilegeModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.RolePrivilegeModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SSHGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SSHGet(params *clientsecurity.SSHGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SSHGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SSHGet")
	}

	var r0 *clientsecurity.SSHGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SSHGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SSHGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SSHGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SSHGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SSHGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SSHGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SSHModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SSHModify(params *clientsecurity.SSHModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SSHModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SSHModify")
	}

	var r0 *clientsecurity.SSHModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SSHModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SSHModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SSHModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SSHModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SSHModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SSHModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityAssociationCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityAssociationCollectionGet(params *clientsecurity.SecurityAssociationCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityAssociationCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityAssociationCollectionGet")
	}

	var r0 *clientsecurity.SecurityAssociationCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAssociationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityAssociationCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAssociationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityAssociationCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityAssociationCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityAssociationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityAssociationGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityAssociationGet(params *clientsecurity.SecurityAssociationGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityAssociationGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityAssociationGet")
	}

	var r0 *clientsecurity.SecurityAssociationGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAssociationGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityAssociationGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAssociationGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityAssociationGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityAssociationGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityAssociationGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityAuditGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityAuditGet(params *clientsecurity.SecurityAuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityAuditGet")
	}

	var r0 *clientsecurity.SecurityAuditGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityAuditGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityAuditGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityAuditGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityAuditLogCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityAuditLogCollectionGet(params *clientsecurity.SecurityAuditLogCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditLogCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityAuditLogCollectionGet")
	}

	var r0 *clientsecurity.SecurityAuditLogCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditLogCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityAuditLogCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityAuditLogCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityAuditLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityAuditModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityAuditModify(params *clientsecurity.SecurityAuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityAuditModify")
	}

	var r0 *clientsecurity.SecurityAuditModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityAuditModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityAuditModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityAuditModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityAuditModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityAuditModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityCertificateCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityCertificateCollectionGet(params *clientsecurity.SecurityCertificateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityCertificateCollectionGet")
	}

	var r0 *clientsecurity.SecurityCertificateCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityCertificateCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityCertificateCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityCertificateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityCertificateCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityCertificateCreate(params *clientsecurity.SecurityCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityCertificateCreate")
	}

	var r0 *clientsecurity.SecurityCertificateCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityCertificateCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityCertificateCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityCertificateCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityCertificateDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityCertificateDelete(params *clientsecurity.SecurityCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityCertificateDelete")
	}

	var r0 *clientsecurity.SecurityCertificateDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityCertificateDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityCertificateDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityCertificateDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityCertificateGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityCertificateGet(params *clientsecurity.SecurityCertificateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityCertificateGet")
	}

	var r0 *clientsecurity.SecurityCertificateGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityCertificateGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityCertificateGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityCertificateGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityCertificateSign provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityCertificateSign(params *clientsecurity.SecurityCertificateSignParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateSignOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityCertificateSign")
	}

	var r0 *clientsecurity.SecurityCertificateSignOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateSignParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityCertificateSignOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityCertificateSignParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityCertificateSignOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityCertificateSignOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityCertificateSignParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityConfigGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityConfigGet(params *clientsecurity.SecurityConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityConfigGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityConfigGet")
	}

	var r0 *clientsecurity.SecurityConfigGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityConfigGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityConfigGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityConfigGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityConfigGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityConfigModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityConfigModify(params *clientsecurity.SecurityConfigModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityConfigModifyOK, *clientsecurity.SecurityConfigModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityConfigModify")
	}

	var r0 *clientsecurity.SecurityConfigModifyOK
	var r1 *clientsecurity.SecurityConfigModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityConfigModifyOK, *clientsecurity.SecurityConfigModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityConfigModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityConfigModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityConfigModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityConfigModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityConfigModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityKeyManagerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerCollectionGet(params *clientsecurity.SecurityKeyManagerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerCollectionGet")
	}

	var r0 *clientsecurity.SecurityKeyManagerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerCreate(params *clientsecurity.SecurityKeyManagerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerCreate")
	}

	var r0 *clientsecurity.SecurityKeyManagerCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerDelete(params *clientsecurity.SecurityKeyManagerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerDelete")
	}

	var r0 *clientsecurity.SecurityKeyManagerDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerGet(params *clientsecurity.SecurityKeyManagerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerGet")
	}

	var r0 *clientsecurity.SecurityKeyManagerGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerKeyServersCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerKeyServersCollectionGet(params *clientsecurity.SecurityKeyManagerKeyServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerKeyServersCollectionGet")
	}

	var r0 *clientsecurity.SecurityKeyManagerKeyServersCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerKeyServersCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerKeyServersCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerKeyServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerKeyServersCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerKeyServersCreate(params *clientsecurity.SecurityKeyManagerKeyServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerKeyServersCreate")
	}

	var r0 *clientsecurity.SecurityKeyManagerKeyServersCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerKeyServersCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerKeyServersCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerKeyServersCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerKeyServersDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerKeyServersDelete(params *clientsecurity.SecurityKeyManagerKeyServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerKeyServersDelete")
	}

	var r0 *clientsecurity.SecurityKeyManagerKeyServersDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerKeyServersDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerKeyServersDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerKeyServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerKeyServersGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerKeyServersGet(params *clientsecurity.SecurityKeyManagerKeyServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerKeyServersGet")
	}

	var r0 *clientsecurity.SecurityKeyManagerKeyServersGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerKeyServersGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerKeyServersGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerKeyServersGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerKeyServersModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerKeyServersModify(params *clientsecurity.SecurityKeyManagerKeyServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerKeyServersModify")
	}

	var r0 *clientsecurity.SecurityKeyManagerKeyServersModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerKeyServersModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerKeyServersModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerKeyServersModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerKeyServersModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerKeyServersModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerMigrate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerMigrate(params *clientsecurity.SecurityKeyManagerMigrateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerMigrateCreated, *clientsecurity.SecurityKeyManagerMigrateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerMigrate")
	}

	var r0 *clientsecurity.SecurityKeyManagerMigrateCreated
	var r1 *clientsecurity.SecurityKeyManagerMigrateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerMigrateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerMigrateCreated, *clientsecurity.SecurityKeyManagerMigrateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerMigrateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerMigrateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerMigrateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerMigrateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerMigrateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityKeyManagerMigrateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityKeyManagerMigrateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityKeyManagerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerModify(params *clientsecurity.SecurityKeyManagerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerModify")
	}

	var r0 *clientsecurity.SecurityKeyManagerModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeyManagerRestore provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeyManagerRestore(params *clientsecurity.SecurityKeyManagerRestoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerRestoreCreated, *clientsecurity.SecurityKeyManagerRestoreAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeyManagerRestore")
	}

	var r0 *clientsecurity.SecurityKeyManagerRestoreCreated
	var r1 *clientsecurity.SecurityKeyManagerRestoreAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeyManagerRestoreCreated, *clientsecurity.SecurityKeyManagerRestoreAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeyManagerRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerRestoreCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeyManagerRestoreCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeyManagerRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeyManagerRestoreAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityKeyManagerRestoreAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityKeyManagerRestoreParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityKeystoreCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeystoreCollectionGet(params *clientsecurity.SecurityKeystoreCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeystoreCollectionGet")
	}

	var r0 *clientsecurity.SecurityKeystoreCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeystoreCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeystoreCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeystoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeystoreDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeystoreDelete(params *clientsecurity.SecurityKeystoreDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeystoreDelete")
	}

	var r0 *clientsecurity.SecurityKeystoreDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeystoreDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeystoreDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeystoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeystoreGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeystoreGet(params *clientsecurity.SecurityKeystoreGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeystoreGet")
	}

	var r0 *clientsecurity.SecurityKeystoreGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeystoreGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeystoreGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeystoreGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityKeystoreModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityKeystoreModify(params *clientsecurity.SecurityKeystoreModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreModifyOK, *clientsecurity.SecurityKeystoreModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityKeystoreModify")
	}

	var r0 *clientsecurity.SecurityKeystoreModifyOK
	var r1 *clientsecurity.SecurityKeystoreModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityKeystoreModifyOK, *clientsecurity.SecurityKeystoreModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityKeystoreModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeystoreModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityKeystoreModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityKeystoreModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityKeystoreModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityKeystoreModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityKeystoreModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityLogForwardingCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityLogForwardingCreate(params *clientsecurity.SecurityLogForwardingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingCreateCreated, *clientsecurity.SecurityLogForwardingCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityLogForwardingCreate")
	}

	var r0 *clientsecurity.SecurityLogForwardingCreateCreated
	var r1 *clientsecurity.SecurityLogForwardingCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingCreateCreated, *clientsecurity.SecurityLogForwardingCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityLogForwardingCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityLogForwardingCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityLogForwardingCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityLogForwardingCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityLogForwardingCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityLogForwardingCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityLogForwardingDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityLogForwardingDelete(params *clientsecurity.SecurityLogForwardingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityLogForwardingDelete")
	}

	var r0 *clientsecurity.SecurityLogForwardingDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityLogForwardingDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityLogForwardingDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityLogForwardingDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityLogForwardingGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityLogForwardingGet(params *clientsecurity.SecurityLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityLogForwardingGet")
	}

	var r0 *clientsecurity.SecurityLogForwardingGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityLogForwardingGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityLogForwardingGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityLogForwardingGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityLogForwardingModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityLogForwardingModify(params *clientsecurity.SecurityLogForwardingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityLogForwardingModify")
	}

	var r0 *clientsecurity.SecurityLogForwardingModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityLogForwardingModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityLogForwardingModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityLogForwardingModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityLogForwardingModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityLogForwardingModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityOauth2CollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2CollectionGet(params *clientsecurity.SecurityOauth2CollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2CollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2CollectionGet")
	}

	var r0 *clientsecurity.SecurityOauth2CollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2CollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2CollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2CollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2CollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2CollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2CollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityOauth2Create provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2Create(params *clientsecurity.SecurityOauth2CreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2CreateCreated, *clientsecurity.SecurityOauth2CreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2Create")
	}

	var r0 *clientsecurity.SecurityOauth2CreateCreated
	var r1 *clientsecurity.SecurityOauth2CreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2CreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2CreateCreated, *clientsecurity.SecurityOauth2CreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2CreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2CreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2CreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2CreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2CreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecurityOauth2CreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecurityOauth2CreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecurityOauth2Delete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2Delete(params *clientsecurity.SecurityOauth2DeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2DeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2Delete")
	}

	var r0 *clientsecurity.SecurityOauth2DeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2DeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2DeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2DeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2DeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2DeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2DeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityOauth2Get provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2Get(params *clientsecurity.SecurityOauth2GetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2Get")
	}

	var r0 *clientsecurity.SecurityOauth2GetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2GetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2GetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2GetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityOauth2GlobalGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2GlobalGet(params *clientsecurity.SecurityOauth2GlobalGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GlobalGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2GlobalGet")
	}

	var r0 *clientsecurity.SecurityOauth2GlobalGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GlobalGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GlobalGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GlobalGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2GlobalGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2GlobalGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2GlobalGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecurityOauth2GlobalModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecurityOauth2GlobalModify(params *clientsecurity.SecurityOauth2GlobalModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GlobalModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecurityOauth2GlobalModify")
	}

	var r0 *clientsecurity.SecurityOauth2GlobalModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GlobalModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecurityOauth2GlobalModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecurityOauth2GlobalModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecurityOauth2GlobalModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecurityOauth2GlobalModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecurityOauth2GlobalModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecuritySamlSpCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecuritySamlSpCreate(params *clientsecurity.SecuritySamlSpCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpCreateCreated, *clientsecurity.SecuritySamlSpCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecuritySamlSpCreate")
	}

	var r0 *clientsecurity.SecuritySamlSpCreateCreated
	var r1 *clientsecurity.SecuritySamlSpCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpCreateCreated, *clientsecurity.SecuritySamlSpCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecuritySamlSpCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecuritySamlSpCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecuritySamlSpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecuritySamlSpCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsecurity.SecuritySamlSpCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsecurity.SecuritySamlSpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SecuritySamlSpDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecuritySamlSpDelete(params *clientsecurity.SecuritySamlSpDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecuritySamlSpDelete")
	}

	var r0 *clientsecurity.SecuritySamlSpDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecuritySamlSpDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecuritySamlSpDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecuritySamlSpDeleteParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecuritySamlSpGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecuritySamlSpGet(params *clientsecurity.SecuritySamlSpGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecuritySamlSpGet")
	}

	var r0 *clientsecurity.SecuritySamlSpGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecuritySamlSpGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecuritySamlSpGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecuritySamlSpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SecuritySamlSpModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SecuritySamlSpModify(params *clientsecurity.SecuritySamlSpModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SecuritySamlSpModify")
	}

	var r0 *clientsecurity.SecuritySamlSpModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SecuritySamlSpModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SecuritySamlSpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SecuritySamlSpModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SecuritySamlSpModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SecuritySamlSpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// SvmSSHServerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmSSHServerCollectionGet(params *clientsecurity.SvmSSHServerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmSSHServerCollectionGet")
	}

	var r0 *clientsecurity.SvmSSHServerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SvmSSHServerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SvmSSHServerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SvmSSHServerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmSSHServerGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmSSHServerGet(params *clientsecurity.SvmSSHServerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmSSHServerGet")
	}

	var r0 *clientsecurity.SvmSSHServerGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SvmSSHServerGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SvmSSHServerGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SvmSSHServerGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SvmSSHServerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SvmSSHServerModify(params *clientsecurity.SvmSSHServerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SvmSSHServerModify")
	}

	var r0 *clientsecurity.SvmSSHServerModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.SvmSSHServerModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.SvmSSHServerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.SvmSSHServerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.SvmSSHServerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.SvmSSHServerModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TotpCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TotpCollectionGet(params *clientsecurity.TotpCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.TotpCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TotpCollectionGet")
	}

	var r0 *clientsecurity.TotpCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.TotpCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.TotpCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.TotpCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.TotpCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TotpCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TotpCreate(params *clientsecurity.TotpCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.TotpCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TotpCreate")
	}

	var r0 *clientsecurity.TotpCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.TotpCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.TotpCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.TotpCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.TotpCreateParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TotpGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TotpGet(params *clientsecurity.TotpGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.TotpGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TotpGet")
	}

	var r0 *clientsecurity.TotpGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.TotpGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.TotpGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.TotpGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.TotpGetParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TotpModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TotpModify(params *clientsecurity.TotpModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsecurity.ClientOption) (*clientsecurity.TotpModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TotpModify")
	}

	var r0 *clientsecurity.TotpModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) (*clientsecurity.TotpModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsecurity.TotpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) *clientsecurity.TotpModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsecurity.TotpModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsecurity.TotpModifyParams, runtime.ClientAuthInfoWriter, ...clientsecurity.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
