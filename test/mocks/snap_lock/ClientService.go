// Code generated by mockery v2.51.0. DO NOT EDIT.

package snap_lock

import (
	clientsnap_lock "github.com/metal-stack/ontap-go/api/client/snap_lock"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// SnaplockComplianceClockCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockComplianceClockCollectionGet(params *clientsnap_lock.SnaplockComplianceClockCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockComplianceClockCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockComplianceClockCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockComplianceClockCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockComplianceClockCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockComplianceClockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockComplianceClockCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockComplianceClockCreate(params *clientsnap_lock.SnaplockComplianceClockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockComplianceClockCreate")
	}

	var r0 *clientsnap_lock.SnaplockComplianceClockCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockComplianceClockCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockComplianceClockCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockComplianceClockCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockComplianceClockGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockComplianceClockGet(params *clientsnap_lock.SnaplockComplianceClockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockComplianceClockGet")
	}

	var r0 *clientsnap_lock.SnaplockComplianceClockGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockComplianceClockGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockComplianceClockGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockComplianceClockGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockComplianceClockGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockComplianceClockGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFilePrivilegedDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFilePrivilegedDelete(params *clientsnap_lock.SnaplockFilePrivilegedDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFilePrivilegedDeleteOK, *clientsnap_lock.SnaplockFilePrivilegedDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFilePrivilegedDelete")
	}

	var r0 *clientsnap_lock.SnaplockFilePrivilegedDeleteOK
	var r1 *clientsnap_lock.SnaplockFilePrivilegedDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFilePrivilegedDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFilePrivilegedDeleteOK, *clientsnap_lock.SnaplockFilePrivilegedDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFilePrivilegedDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFilePrivilegedDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFilePrivilegedDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFilePrivilegedDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFilePrivilegedDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsnap_lock.SnaplockFilePrivilegedDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsnap_lock.SnaplockFilePrivilegedDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnaplockFileRetentionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFileRetentionGet(params *clientsnap_lock.SnaplockFileRetentionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFileRetentionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFileRetentionGet")
	}

	var r0 *clientsnap_lock.SnaplockFileRetentionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFileRetentionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFileRetentionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFileRetentionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFileRetentionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFileRetentionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFileRetentionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFileRetentionTimeModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFileRetentionTimeModify(params *clientsnap_lock.SnaplockFileRetentionTimeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFileRetentionTimeModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFileRetentionTimeModify")
	}

	var r0 *clientsnap_lock.SnaplockFileRetentionTimeModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFileRetentionTimeModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFileRetentionTimeModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFileRetentionTimeModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFileRetentionTimeModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFileRetentionTimeModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFileRetentionTimeModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFingerprintOperationCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFingerprintOperationCollectionGet(params *clientsnap_lock.SnaplockFingerprintOperationCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFingerprintOperationCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockFingerprintOperationCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFingerprintOperationCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFingerprintOperationCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFingerprintOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFingerprintOperationCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFingerprintOperationCreate(params *clientsnap_lock.SnaplockFingerprintOperationCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFingerprintOperationCreate")
	}

	var r0 *clientsnap_lock.SnaplockFingerprintOperationCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFingerprintOperationCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFingerprintOperationCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFingerprintOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFingerprintOperationDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFingerprintOperationDelete(params *clientsnap_lock.SnaplockFingerprintOperationDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFingerprintOperationDelete")
	}

	var r0 *clientsnap_lock.SnaplockFingerprintOperationDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFingerprintOperationDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFingerprintOperationDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFingerprintOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockFingerprintOperationGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockFingerprintOperationGet(params *clientsnap_lock.SnaplockFingerprintOperationGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockFingerprintOperationGet")
	}

	var r0 *clientsnap_lock.SnaplockFingerprintOperationGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockFingerprintOperationGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockFingerprintOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockFingerprintOperationGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockFingerprintOperationGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockFingerprintOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldBegin provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldBegin(params *clientsnap_lock.SnaplockLegalHoldBeginParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldBeginCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldBegin")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldBeginCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldBeginParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldBeginCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldBeginParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldBeginCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldBeginCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldBeginParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldCollectionGet(params *clientsnap_lock.SnaplockLegalHoldCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldCreate(params *clientsnap_lock.SnaplockLegalHoldCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldCreate")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldDelete(params *clientsnap_lock.SnaplockLegalHoldDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldDelete")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldFilesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldFilesGet(params *clientsnap_lock.SnaplockLegalHoldFilesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldFilesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldFilesGet")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldFilesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldFilesGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldFilesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldFilesGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldFilesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldFilesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldFilesGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldGet(params *clientsnap_lock.SnaplockLegalHoldGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldGet")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldInstanceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldInstanceGet(params *clientsnap_lock.SnaplockLegalHoldInstanceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldInstanceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldInstanceGet")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldInstanceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldInstanceGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldInstanceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldInstanceGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldInstanceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldInstanceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldInstanceGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLegalHoldOperationDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLegalHoldOperationDelete(params *clientsnap_lock.SnaplockLegalHoldOperationDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldOperationDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLegalHoldOperationDelete")
	}

	var r0 *clientsnap_lock.SnaplockLegalHoldOperationDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLegalHoldOperationDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLegalHoldOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLegalHoldOperationDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLegalHoldOperationDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLegalHoldOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLogCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLogCollectionGet(params *clientsnap_lock.SnaplockLogCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLogCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockLogCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLogCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLogCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLogCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLogCreate(params *clientsnap_lock.SnaplockLogCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogCreateCreated, *clientsnap_lock.SnaplockLogCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLogCreate")
	}

	var r0 *clientsnap_lock.SnaplockLogCreateCreated
	var r1 *clientsnap_lock.SnaplockLogCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogCreateCreated, *clientsnap_lock.SnaplockLogCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLogCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLogCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsnap_lock.SnaplockLogCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsnap_lock.SnaplockLogCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnaplockLogDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLogDelete(params *clientsnap_lock.SnaplockLogDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogDeleteOK, *clientsnap_lock.SnaplockLogDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLogDelete")
	}

	var r0 *clientsnap_lock.SnaplockLogDeleteOK
	var r1 *clientsnap_lock.SnaplockLogDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogDeleteOK, *clientsnap_lock.SnaplockLogDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLogDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLogDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsnap_lock.SnaplockLogDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsnap_lock.SnaplockLogDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnaplockLogGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLogGet(params *clientsnap_lock.SnaplockLogGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLogGet")
	}

	var r0 *clientsnap_lock.SnaplockLogGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLogGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLogGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockLogModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockLogModify(params *clientsnap_lock.SnaplockLogModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogModifyOK, *clientsnap_lock.SnaplockLogModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockLogModify")
	}

	var r0 *clientsnap_lock.SnaplockLogModifyOK
	var r1 *clientsnap_lock.SnaplockLogModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockLogModifyOK, *clientsnap_lock.SnaplockLogModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockLogModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockLogModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockLogModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockLogModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientsnap_lock.SnaplockLogModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientsnap_lock.SnaplockLogModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnaplockRetentionOperationCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionOperationCollectionGet(params *clientsnap_lock.SnaplockRetentionOperationCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionOperationCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockRetentionOperationCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionOperationCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionOperationCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionOperationCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionOperationCreate(params *clientsnap_lock.SnaplockRetentionOperationCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionOperationCreate")
	}

	var r0 *clientsnap_lock.SnaplockRetentionOperationCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionOperationCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionOperationCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionOperationCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionOperationDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionOperationDelete(params *clientsnap_lock.SnaplockRetentionOperationDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionOperationDelete")
	}

	var r0 *clientsnap_lock.SnaplockRetentionOperationDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionOperationDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionOperationDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionOperationDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionOperationGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionOperationGet(params *clientsnap_lock.SnaplockRetentionOperationGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionOperationGet")
	}

	var r0 *clientsnap_lock.SnaplockRetentionOperationGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionOperationGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionOperationGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionOperationGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionOperationGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionPolicyCollectionGet(params *clientsnap_lock.SnaplockRetentionPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionPolicyCollectionGet")
	}

	var r0 *clientsnap_lock.SnaplockRetentionPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionPolicyCreate(params *clientsnap_lock.SnaplockRetentionPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionPolicyCreate")
	}

	var r0 *clientsnap_lock.SnaplockRetentionPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionPolicyDelete(params *clientsnap_lock.SnaplockRetentionPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionPolicyDelete")
	}

	var r0 *clientsnap_lock.SnaplockRetentionPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionPolicyGet(params *clientsnap_lock.SnaplockRetentionPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionPolicyGet")
	}

	var r0 *clientsnap_lock.SnaplockRetentionPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnaplockRetentionPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnaplockRetentionPolicyModify(params *clientsnap_lock.SnaplockRetentionPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnaplockRetentionPolicyModify")
	}

	var r0 *clientsnap_lock.SnaplockRetentionPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) (*clientsnap_lock.SnaplockRetentionPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientsnap_lock.SnaplockRetentionPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) *clientsnap_lock.SnaplockRetentionPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientsnap_lock.SnaplockRetentionPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientsnap_lock.SnaplockRetentionPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientsnap_lock.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
