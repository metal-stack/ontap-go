// Code generated by mockery v2.52.3. DO NOT EDIT.

package storage

import (
	clientstorage "github.com/metal-stack/ontap-go/api/client/storage"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// AggregateCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregateCollectionGet(params *clientstorage.AggregateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregateCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregateCollectionGet")
	}

	var r0 *clientstorage.AggregateCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregateCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregateCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregateCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AggregateCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregateCreate(params *clientstorage.AggregateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregateCreateCreated, *clientstorage.AggregateCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregateCreate")
	}

	var r0 *clientstorage.AggregateCreateCreated
	var r1 *clientstorage.AggregateCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregateCreateCreated, *clientstorage.AggregateCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregateCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregateCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.AggregateCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.AggregateCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AggregateDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregateDelete(params *clientstorage.AggregateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregateDeleteOK, *clientstorage.AggregateDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregateDelete")
	}

	var r0 *clientstorage.AggregateDeleteOK
	var r1 *clientstorage.AggregateDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregateDeleteOK, *clientstorage.AggregateDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregateDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregateDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.AggregateDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.AggregateDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AggregateGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregateGet(params *clientstorage.AggregateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregateGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregateGet")
	}

	var r0 *clientstorage.AggregateGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregateGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregateGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregateGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AggregateModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregateModify(params *clientstorage.AggregateModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregateModifyOK, *clientstorage.AggregateModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregateModify")
	}

	var r0 *clientstorage.AggregateModifyOK
	var r1 *clientstorage.AggregateModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregateModifyOK, *clientstorage.AggregateModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregateModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregateModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregateModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregateModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.AggregateModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.AggregateModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AggregatePerformanceMetricsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AggregatePerformanceMetricsCollectionGet(params *clientstorage.AggregatePerformanceMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.AggregatePerformanceMetricsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AggregatePerformanceMetricsCollectionGet")
	}

	var r0 *clientstorage.AggregatePerformanceMetricsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregatePerformanceMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.AggregatePerformanceMetricsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.AggregatePerformanceMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.AggregatePerformanceMetricsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.AggregatePerformanceMetricsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.AggregatePerformanceMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudStoreCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CloudStoreCollectionGet(params *clientstorage.CloudStoreCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.CloudStoreCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloudStoreCollectionGet")
	}

	var r0 *clientstorage.CloudStoreCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.CloudStoreCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.CloudStoreCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.CloudStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudStoreCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CloudStoreCreate(params *clientstorage.CloudStoreCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.CloudStoreCreateCreated, *clientstorage.CloudStoreCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloudStoreCreate")
	}

	var r0 *clientstorage.CloudStoreCreateCreated
	var r1 *clientstorage.CloudStoreCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.CloudStoreCreateCreated, *clientstorage.CloudStoreCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.CloudStoreCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.CloudStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.CloudStoreCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.CloudStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudStoreDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CloudStoreDelete(params *clientstorage.CloudStoreDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.CloudStoreDeleteOK, *clientstorage.CloudStoreDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloudStoreDelete")
	}

	var r0 *clientstorage.CloudStoreDeleteOK
	var r1 *clientstorage.CloudStoreDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.CloudStoreDeleteOK, *clientstorage.CloudStoreDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.CloudStoreDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.CloudStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.CloudStoreDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.CloudStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudStoreGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CloudStoreGet(params *clientstorage.CloudStoreGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.CloudStoreGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloudStoreGet")
	}

	var r0 *clientstorage.CloudStoreGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.CloudStoreGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.CloudStoreGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.CloudStoreGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudStoreModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CloudStoreModify(params *clientstorage.CloudStoreModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.CloudStoreModifyOK, *clientstorage.CloudStoreModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloudStoreModify")
	}

	var r0 *clientstorage.CloudStoreModifyOK
	var r1 *clientstorage.CloudStoreModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.CloudStoreModifyOK, *clientstorage.CloudStoreModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.CloudStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.CloudStoreModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.CloudStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.CloudStoreModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.CloudStoreModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.CloudStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiskCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DiskCollectionGet(params *clientstorage.DiskCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.DiskCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DiskCollectionGet")
	}

	var r0 *clientstorage.DiskCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.DiskCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.DiskCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.DiskCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.DiskCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiskGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DiskGet(params *clientstorage.DiskGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.DiskGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DiskGet")
	}

	var r0 *clientstorage.DiskGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.DiskGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.DiskGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.DiskGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.DiskGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiskModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DiskModify(params *clientstorage.DiskModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.DiskModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DiskModify")
	}

	var r0 *clientstorage.DiskModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.DiskModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.DiskModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.DiskModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.DiskModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.DiskModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileCloneCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileCloneCreate(params *clientstorage.FileCloneCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileCloneCreateCreated, *clientstorage.FileCloneCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileCloneCreate")
	}

	var r0 *clientstorage.FileCloneCreateCreated
	var r1 *clientstorage.FileCloneCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileCloneCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileCloneCreateCreated, *clientstorage.FileCloneCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileCloneCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileCloneCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileCloneCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileCloneCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileCloneCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FileCloneCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FileCloneCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileCopyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileCopyCreate(params *clientstorage.FileCopyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileCopyCreateCreated, *clientstorage.FileCopyCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileCopyCreate")
	}

	var r0 *clientstorage.FileCopyCreateCreated
	var r1 *clientstorage.FileCopyCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileCopyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileCopyCreateCreated, *clientstorage.FileCopyCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileCopyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileCopyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileCopyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileCopyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileCopyCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FileCopyCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FileCopyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDelete(params *clientstorage.FileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileDeleteOK, *clientstorage.FileDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDelete")
	}

	var r0 *clientstorage.FileDeleteOK
	var r1 *clientstorage.FileDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileDeleteOK, *clientstorage.FileDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FileDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FileDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileInfoCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileInfoCollectionGet(params *clientstorage.FileInfoCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileInfoCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileInfoCollectionGet")
	}

	var r0 *clientstorage.FileInfoCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileInfoCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileInfoCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileInfoCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileInfoCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileInfoCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileInfoCreate(params *clientstorage.FileInfoCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileInfoCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileInfoCreate")
	}

	var r0 *clientstorage.FileInfoCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileInfoCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileInfoCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileInfoCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileInfoCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileInfoModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileInfoModify(params *clientstorage.FileInfoModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileInfoModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileInfoModify")
	}

	var r0 *clientstorage.FileInfoModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileInfoModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileInfoModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileInfoModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileInfoModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileInfoModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileMoveCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileMoveCollectionGet(params *clientstorage.FileMoveCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileMoveCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileMoveCollectionGet")
	}

	var r0 *clientstorage.FileMoveCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileMoveCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileMoveCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileMoveCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileMoveCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileMoveCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileMoveCreate(params *clientstorage.FileMoveCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileMoveCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileMoveCreate")
	}

	var r0 *clientstorage.FileMoveCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileMoveCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileMoveCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileMoveCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileMoveCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileMoveGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileMoveGet(params *clientstorage.FileMoveGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FileMoveGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileMoveGet")
	}

	var r0 *clientstorage.FileMoveGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FileMoveGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FileMoveGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FileMoveGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FileMoveGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FileMoveGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlexcacheCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheCollectionGet(params *clientstorage.FlexcacheCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheCollectionGet")
	}

	var r0 *clientstorage.FlexcacheCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlexcacheCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheCreate(params *clientstorage.FlexcacheCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheCreateCreated, *clientstorage.FlexcacheCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheCreate")
	}

	var r0 *clientstorage.FlexcacheCreateCreated
	var r1 *clientstorage.FlexcacheCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheCreateCreated, *clientstorage.FlexcacheCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FlexcacheCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FlexcacheCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FlexcacheDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheDelete(params *clientstorage.FlexcacheDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheDeleteOK, *clientstorage.FlexcacheDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheDelete")
	}

	var r0 *clientstorage.FlexcacheDeleteOK
	var r1 *clientstorage.FlexcacheDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheDeleteOK, *clientstorage.FlexcacheDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FlexcacheDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FlexcacheDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FlexcacheGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheGet(params *clientstorage.FlexcacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheGet")
	}

	var r0 *clientstorage.FlexcacheGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlexcacheModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheModify(params *clientstorage.FlexcacheModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheModifyOK, *clientstorage.FlexcacheModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheModify")
	}

	var r0 *clientstorage.FlexcacheModifyOK
	var r1 *clientstorage.FlexcacheModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheModifyOK, *clientstorage.FlexcacheModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FlexcacheModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FlexcacheModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FlexcacheOriginCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheOriginCollectionGet(params *clientstorage.FlexcacheOriginCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheOriginCollectionGet")
	}

	var r0 *clientstorage.FlexcacheOriginCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheOriginCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheOriginCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheOriginCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlexcacheOriginGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheOriginGet(params *clientstorage.FlexcacheOriginGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheOriginGet")
	}

	var r0 *clientstorage.FlexcacheOriginGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheOriginGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheOriginGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheOriginGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlexcacheOriginModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FlexcacheOriginModify(params *clientstorage.FlexcacheOriginModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginModifyOK, *clientstorage.FlexcacheOriginModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlexcacheOriginModify")
	}

	var r0 *clientstorage.FlexcacheOriginModifyOK
	var r1 *clientstorage.FlexcacheOriginModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.FlexcacheOriginModifyOK, *clientstorage.FlexcacheOriginModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.FlexcacheOriginModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheOriginModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.FlexcacheOriginModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.FlexcacheOriginModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.FlexcacheOriginModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.FlexcacheOriginModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.FlexcacheOriginModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PlexCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PlexCollectionGet(params *clientstorage.PlexCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.PlexCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PlexCollectionGet")
	}

	var r0 *clientstorage.PlexCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.PlexCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.PlexCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.PlexCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.PlexCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.PlexCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.PlexCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PlexGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PlexGet(params *clientstorage.PlexGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.PlexGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PlexGet")
	}

	var r0 *clientstorage.PlexGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.PlexGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.PlexGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.PlexGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.PlexGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.PlexGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.PlexGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PortCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PortCollectionGet(params *clientstorage.PortCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.PortCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PortCollectionGet")
	}

	var r0 *clientstorage.PortCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.PortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.PortCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.PortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.PortCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.PortCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.PortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PortGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PortGet(params *clientstorage.PortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.PortGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PortGet")
	}

	var r0 *clientstorage.PortGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.PortGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.PortGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.PortGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.PortGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.PortGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.PortGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosOptionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosOptionGet(params *clientstorage.QosOptionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosOptionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosOptionGet")
	}

	var r0 *clientstorage.QosOptionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosOptionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosOptionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosOptionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosOptionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosOptionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosOptionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosOptionModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosOptionModify(params *clientstorage.QosOptionModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosOptionModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosOptionModify")
	}

	var r0 *clientstorage.QosOptionModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosOptionModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosOptionModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosOptionModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosOptionModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosOptionModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosOptionModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosPolicyCollectionGet(params *clientstorage.QosPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosPolicyCollectionGet")
	}

	var r0 *clientstorage.QosPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosPolicyCreate(params *clientstorage.QosPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosPolicyCreateCreated, *clientstorage.QosPolicyCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosPolicyCreate")
	}

	var r0 *clientstorage.QosPolicyCreateCreated
	var r1 *clientstorage.QosPolicyCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosPolicyCreateCreated, *clientstorage.QosPolicyCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QosPolicyCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QosPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QosPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosPolicyDelete(params *clientstorage.QosPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosPolicyDelete")
	}

	var r0 *clientstorage.QosPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosPolicyGet(params *clientstorage.QosPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosPolicyGet")
	}

	var r0 *clientstorage.QosPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosPolicyModify(params *clientstorage.QosPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosPolicyModifyOK, *clientstorage.QosPolicyModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosPolicyModify")
	}

	var r0 *clientstorage.QosPolicyModifyOK
	var r1 *clientstorage.QosPolicyModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosPolicyModifyOK, *clientstorage.QosPolicyModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosPolicyModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QosPolicyModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QosPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QosWorkloadCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosWorkloadCollectionGet(params *clientstorage.QosWorkloadCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosWorkloadCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosWorkloadCollectionGet")
	}

	var r0 *clientstorage.QosWorkloadCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosWorkloadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosWorkloadCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosWorkloadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosWorkloadCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosWorkloadCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosWorkloadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QosWorkloadGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QosWorkloadGet(params *clientstorage.QosWorkloadGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QosWorkloadGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QosWorkloadGet")
	}

	var r0 *clientstorage.QosWorkloadGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QosWorkloadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QosWorkloadGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QosWorkloadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QosWorkloadGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QosWorkloadGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QosWorkloadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QtreeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QtreeCollectionGet(params *clientstorage.QtreeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QtreeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QtreeCollectionGet")
	}

	var r0 *clientstorage.QtreeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QtreeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QtreeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QtreeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QtreeCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QtreeCreate(params *clientstorage.QtreeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QtreeCreateCreated, *clientstorage.QtreeCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QtreeCreate")
	}

	var r0 *clientstorage.QtreeCreateCreated
	var r1 *clientstorage.QtreeCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QtreeCreateCreated, *clientstorage.QtreeCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QtreeCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QtreeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QtreeCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QtreeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QtreeDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QtreeDelete(params *clientstorage.QtreeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QtreeDeleteOK, *clientstorage.QtreeDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QtreeDelete")
	}

	var r0 *clientstorage.QtreeDeleteOK
	var r1 *clientstorage.QtreeDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QtreeDeleteOK, *clientstorage.QtreeDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QtreeDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QtreeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QtreeDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QtreeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QtreeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QtreeGet(params *clientstorage.QtreeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QtreeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QtreeGet")
	}

	var r0 *clientstorage.QtreeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QtreeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QtreeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QtreeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QtreeModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QtreeModify(params *clientstorage.QtreeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QtreeModifyOK, *clientstorage.QtreeModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QtreeModify")
	}

	var r0 *clientstorage.QtreeModifyOK
	var r1 *clientstorage.QtreeModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QtreeModifyOK, *clientstorage.QtreeModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QtreeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QtreeModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QtreeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QtreeModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QtreeModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QtreeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QuotaReportCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaReportCollectionGet(params *clientstorage.QuotaReportCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaReportCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaReportCollectionGet")
	}

	var r0 *clientstorage.QuotaReportCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaReportCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaReportCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaReportCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaReportCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaReportCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaReportCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuotaReportGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaReportGet(params *clientstorage.QuotaReportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaReportGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaReportGet")
	}

	var r0 *clientstorage.QuotaReportGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaReportGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaReportGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaReportGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaReportGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaReportGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaReportGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuotaRuleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaRuleCollectionGet(params *clientstorage.QuotaRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaRuleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaRuleCollectionGet")
	}

	var r0 *clientstorage.QuotaRuleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaRuleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaRuleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuotaRuleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaRuleCreate(params *clientstorage.QuotaRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaRuleCreateCreated, *clientstorage.QuotaRuleCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaRuleCreate")
	}

	var r0 *clientstorage.QuotaRuleCreateCreated
	var r1 *clientstorage.QuotaRuleCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaRuleCreateCreated, *clientstorage.QuotaRuleCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaRuleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QuotaRuleCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QuotaRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QuotaRuleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaRuleDelete(params *clientstorage.QuotaRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaRuleDeleteOK, *clientstorage.QuotaRuleDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaRuleDelete")
	}

	var r0 *clientstorage.QuotaRuleDeleteOK
	var r1 *clientstorage.QuotaRuleDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaRuleDeleteOK, *clientstorage.QuotaRuleDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaRuleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QuotaRuleDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QuotaRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// QuotaRuleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaRuleGet(params *clientstorage.QuotaRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaRuleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaRuleGet")
	}

	var r0 *clientstorage.QuotaRuleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaRuleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaRuleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaRuleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuotaRuleModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QuotaRuleModify(params *clientstorage.QuotaRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.QuotaRuleModifyOK, *clientstorage.QuotaRuleModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuotaRuleModify")
	}

	var r0 *clientstorage.QuotaRuleModifyOK
	var r1 *clientstorage.QuotaRuleModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.QuotaRuleModifyOK, *clientstorage.QuotaRuleModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.QuotaRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.QuotaRuleModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.QuotaRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.QuotaRuleModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.QuotaRuleModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.QuotaRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// ShelfCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShelfCollectionGet(params *clientstorage.ShelfCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.ShelfCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShelfCollectionGet")
	}

	var r0 *clientstorage.ShelfCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.ShelfCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.ShelfCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.ShelfCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.ShelfCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShelfGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShelfGet(params *clientstorage.ShelfGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.ShelfGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShelfGet")
	}

	var r0 *clientstorage.ShelfGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.ShelfGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.ShelfGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.ShelfGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.ShelfGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShelfModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShelfModify(params *clientstorage.ShelfModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.ShelfModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShelfModify")
	}

	var r0 *clientstorage.ShelfModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.ShelfModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.ShelfModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.ShelfModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.ShelfModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.ShelfModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotCollectionGet(params *clientstorage.SnapshotCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotCollectionGet")
	}

	var r0 *clientstorage.SnapshotCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotCreate(params *clientstorage.SnapshotCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotCreateCreated, *clientstorage.SnapshotCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotCreate")
	}

	var r0 *clientstorage.SnapshotCreateCreated
	var r1 *clientstorage.SnapshotCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotCreateCreated, *clientstorage.SnapshotCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.SnapshotCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.SnapshotCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnapshotDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotDelete(params *clientstorage.SnapshotDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotDeleteOK, *clientstorage.SnapshotDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotDelete")
	}

	var r0 *clientstorage.SnapshotDeleteOK
	var r1 *clientstorage.SnapshotDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotDeleteOK, *clientstorage.SnapshotDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.SnapshotDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.SnapshotDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnapshotGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotGet(params *clientstorage.SnapshotGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotGet")
	}

	var r0 *clientstorage.SnapshotGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotModify(params *clientstorage.SnapshotModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotModifyOK, *clientstorage.SnapshotModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotModify")
	}

	var r0 *clientstorage.SnapshotModifyOK
	var r1 *clientstorage.SnapshotModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotModifyOK, *clientstorage.SnapshotModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.SnapshotModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.SnapshotModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SnapshotPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyCollectionGet(params *clientstorage.SnapshotPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyCollectionGet")
	}

	var r0 *clientstorage.SnapshotPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyCreate(params *clientstorage.SnapshotPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyCreate")
	}

	var r0 *clientstorage.SnapshotPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyDelete(params *clientstorage.SnapshotPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyDelete")
	}

	var r0 *clientstorage.SnapshotPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyGet(params *clientstorage.SnapshotPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyGet")
	}

	var r0 *clientstorage.SnapshotPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyModify(params *clientstorage.SnapshotPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyModify")
	}

	var r0 *clientstorage.SnapshotPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyScheduleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyScheduleCollectionGet(params *clientstorage.SnapshotPolicyScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyScheduleCollectionGet")
	}

	var r0 *clientstorage.SnapshotPolicyScheduleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyScheduleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyScheduleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyScheduleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyScheduleCreate(params *clientstorage.SnapshotPolicyScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyScheduleCreate")
	}

	var r0 *clientstorage.SnapshotPolicyScheduleCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyScheduleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyScheduleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyScheduleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyScheduleDelete(params *clientstorage.SnapshotPolicyScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyScheduleDelete")
	}

	var r0 *clientstorage.SnapshotPolicyScheduleDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyScheduleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyScheduleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyScheduleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyScheduleGet(params *clientstorage.SnapshotPolicyScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyScheduleGet")
	}

	var r0 *clientstorage.SnapshotPolicyScheduleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyScheduleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyScheduleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotPolicyScheduleModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SnapshotPolicyScheduleModify(params *clientstorage.SnapshotPolicyScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnapshotPolicyScheduleModify")
	}

	var r0 *clientstorage.SnapshotPolicyScheduleModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SnapshotPolicyScheduleModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SnapshotPolicyScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SnapshotPolicyScheduleModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SnapshotPolicyScheduleModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SnapshotPolicyScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitLoadCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SplitLoadCollectionGet(params *clientstorage.SplitLoadCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SplitLoadCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitLoadCollectionGet")
	}

	var r0 *clientstorage.SplitLoadCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SplitLoadCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SplitLoadCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SplitLoadCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SplitLoadCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitLoadGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SplitLoadGet(params *clientstorage.SplitLoadGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SplitLoadGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitLoadGet")
	}

	var r0 *clientstorage.SplitLoadGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SplitLoadGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SplitLoadGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SplitLoadGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SplitLoadGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitLoadModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SplitLoadModify(params *clientstorage.SplitLoadModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SplitLoadModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitLoadModify")
	}

	var r0 *clientstorage.SplitLoadModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SplitLoadModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitLoadModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SplitLoadModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SplitLoadModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SplitLoadModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitStatusCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SplitStatusCollectionGet(params *clientstorage.SplitStatusCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SplitStatusCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitStatusCollectionGet")
	}

	var r0 *clientstorage.SplitStatusCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitStatusCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SplitStatusCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitStatusCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SplitStatusCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SplitStatusCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SplitStatusCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitStatusGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SplitStatusGet(params *clientstorage.SplitStatusGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.SplitStatusGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitStatusGet")
	}

	var r0 *clientstorage.SplitStatusGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitStatusGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.SplitStatusGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.SplitStatusGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.SplitStatusGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.SplitStatusGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.SplitStatusGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDirectoryRestore provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StartDirectoryRestore(params *clientstorage.StartDirectoryRestoreParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StartDirectoryRestoreCreated, *clientstorage.StartDirectoryRestoreAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDirectoryRestore")
	}

	var r0 *clientstorage.StartDirectoryRestoreCreated
	var r1 *clientstorage.StartDirectoryRestoreAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StartDirectoryRestoreParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StartDirectoryRestoreCreated, *clientstorage.StartDirectoryRestoreAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StartDirectoryRestoreParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StartDirectoryRestoreCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StartDirectoryRestoreCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StartDirectoryRestoreParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StartDirectoryRestoreAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.StartDirectoryRestoreAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.StartDirectoryRestoreParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageBridgeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StorageBridgeCollectionGet(params *clientstorage.StorageBridgeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StorageBridgeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StorageBridgeCollectionGet")
	}

	var r0 *clientstorage.StorageBridgeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageBridgeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StorageBridgeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageBridgeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StorageBridgeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StorageBridgeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StorageBridgeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageBridgeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StorageBridgeGet(params *clientstorage.StorageBridgeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StorageBridgeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StorageBridgeGet")
	}

	var r0 *clientstorage.StorageBridgeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageBridgeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StorageBridgeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageBridgeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StorageBridgeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StorageBridgeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StorageBridgeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageClusterGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StorageClusterGet(params *clientstorage.StorageClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StorageClusterGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StorageClusterGet")
	}

	var r0 *clientstorage.StorageClusterGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageClusterGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StorageClusterGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageClusterGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StorageClusterGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StorageClusterGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StorageClusterGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoragePoolCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePoolCollectionGet(params *clientstorage.StoragePoolCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePoolCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePoolCollectionGet")
	}

	var r0 *clientstorage.StoragePoolCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePoolCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePoolCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoragePoolCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePoolCreate(params *clientstorage.StoragePoolCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePoolCreateCreated, *clientstorage.StoragePoolCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePoolCreate")
	}

	var r0 *clientstorage.StoragePoolCreateCreated
	var r1 *clientstorage.StoragePoolCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePoolCreateCreated, *clientstorage.StoragePoolCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePoolCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePoolCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.StoragePoolCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.StoragePoolCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StoragePoolDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePoolDelete(params *clientstorage.StoragePoolDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePoolDeleteOK, *clientstorage.StoragePoolDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePoolDelete")
	}

	var r0 *clientstorage.StoragePoolDeleteOK
	var r1 *clientstorage.StoragePoolDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePoolDeleteOK, *clientstorage.StoragePoolDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePoolDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePoolDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.StoragePoolDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.StoragePoolDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StoragePoolGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePoolGet(params *clientstorage.StoragePoolGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePoolGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePoolGet")
	}

	var r0 *clientstorage.StoragePoolGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePoolGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePoolGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePoolGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoragePoolModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePoolModify(params *clientstorage.StoragePoolModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePoolModifyOK, *clientstorage.StoragePoolModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePoolModify")
	}

	var r0 *clientstorage.StoragePoolModifyOK
	var r1 *clientstorage.StoragePoolModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePoolModifyOK, *clientstorage.StoragePoolModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePoolModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePoolModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePoolModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePoolModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.StoragePoolModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.StoragePoolModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StoragePortModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StoragePortModify(params *clientstorage.StoragePortModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StoragePortModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoragePortModify")
	}

	var r0 *clientstorage.StoragePortModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePortModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StoragePortModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StoragePortModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StoragePortModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StoragePortModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StoragePortModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageSwitchCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StorageSwitchCollectionGet(params *clientstorage.StorageSwitchCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StorageSwitchCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StorageSwitchCollectionGet")
	}

	var r0 *clientstorage.StorageSwitchCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StorageSwitchCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StorageSwitchCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StorageSwitchCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StorageSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageSwitchGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) StorageSwitchGet(params *clientstorage.StorageSwitchGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.StorageSwitchGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StorageSwitchGet")
	}

	var r0 *clientstorage.StorageSwitchGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.StorageSwitchGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.StorageSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.StorageSwitchGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.StorageSwitchGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.StorageSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TapeDeviceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TapeDeviceCollectionGet(params *clientstorage.TapeDeviceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TapeDeviceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TapeDeviceCollectionGet")
	}

	var r0 *clientstorage.TapeDeviceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TapeDeviceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TapeDeviceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TapeDeviceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TapeDeviceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TapeDeviceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TapeDeviceGet(params *clientstorage.TapeDeviceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TapeDeviceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TapeDeviceGet")
	}

	var r0 *clientstorage.TapeDeviceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TapeDeviceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TapeDeviceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TapeDeviceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TapeDeviceGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TapeDeviceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TapeDeviceModify(params *clientstorage.TapeDeviceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TapeDeviceModifyOK, *clientstorage.TapeDeviceModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TapeDeviceModify")
	}

	var r0 *clientstorage.TapeDeviceModifyOK
	var r1 *clientstorage.TapeDeviceModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TapeDeviceModifyOK, *clientstorage.TapeDeviceModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TapeDeviceModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TapeDeviceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TapeDeviceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TapeDeviceModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TapeDeviceModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.TapeDeviceModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.TapeDeviceModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TokenCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TokenCollectionGet(params *clientstorage.TokenCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TokenCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TokenCollectionGet")
	}

	var r0 *clientstorage.TokenCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TokenCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TokenCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TokenCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TokenCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TokenCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TokenCreate(params *clientstorage.TokenCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TokenCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TokenCreate")
	}

	var r0 *clientstorage.TokenCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TokenCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TokenCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TokenCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TokenCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TokenDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TokenDelete(params *clientstorage.TokenDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TokenDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TokenDelete")
	}

	var r0 *clientstorage.TokenDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TokenDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TokenDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TokenDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TokenDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TokenGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TokenGet(params *clientstorage.TokenGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TokenGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TokenGet")
	}

	var r0 *clientstorage.TokenGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TokenGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TokenGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TokenGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TokenGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TokenModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TokenModify(params *clientstorage.TokenModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TokenModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TokenModify")
	}

	var r0 *clientstorage.TokenModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TokenModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TokenModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TokenModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TokenModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TokenModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsClientCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsClientCollectionGet(params *clientstorage.TopMetricsClientCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TopMetricsClientCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsClientCollectionGet")
	}

	var r0 *clientstorage.TopMetricsClientCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TopMetricsClientCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TopMetricsClientCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TopMetricsClientCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TopMetricsClientCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsDirectoryCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsDirectoryCollectionGet(params *clientstorage.TopMetricsDirectoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TopMetricsDirectoryCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsDirectoryCollectionGet")
	}

	var r0 *clientstorage.TopMetricsDirectoryCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TopMetricsDirectoryCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TopMetricsDirectoryCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TopMetricsDirectoryCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TopMetricsDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsFileCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsFileCollectionGet(params *clientstorage.TopMetricsFileCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TopMetricsFileCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsFileCollectionGet")
	}

	var r0 *clientstorage.TopMetricsFileCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TopMetricsFileCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TopMetricsFileCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TopMetricsFileCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TopMetricsFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopMetricsUserCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TopMetricsUserCollectionGet(params *clientstorage.TopMetricsUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.TopMetricsUserCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopMetricsUserCollectionGet")
	}

	var r0 *clientstorage.TopMetricsUserCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.TopMetricsUserCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.TopMetricsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.TopMetricsUserCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.TopMetricsUserCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.TopMetricsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeCollectionGet(params *clientstorage.VolumeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeCollectionGet")
	}

	var r0 *clientstorage.VolumeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeCreate(params *clientstorage.VolumeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeCreateCreated, *clientstorage.VolumeCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeCreate")
	}

	var r0 *clientstorage.VolumeCreateCreated
	var r1 *clientstorage.VolumeCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeCreateCreated, *clientstorage.VolumeCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.VolumeCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.VolumeCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// VolumeDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeDelete(params *clientstorage.VolumeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeDeleteOK, *clientstorage.VolumeDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeDelete")
	}

	var r0 *clientstorage.VolumeDeleteOK
	var r1 *clientstorage.VolumeDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeDeleteOK, *clientstorage.VolumeDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.VolumeDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.VolumeDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// VolumeEfficiencyPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeEfficiencyPolicyCollectionGet(params *clientstorage.VolumeEfficiencyPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeEfficiencyPolicyCollectionGet")
	}

	var r0 *clientstorage.VolumeEfficiencyPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeEfficiencyPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeEfficiencyPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeEfficiencyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeEfficiencyPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeEfficiencyPolicyCreate(params *clientstorage.VolumeEfficiencyPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeEfficiencyPolicyCreate")
	}

	var r0 *clientstorage.VolumeEfficiencyPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeEfficiencyPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeEfficiencyPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeEfficiencyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeEfficiencyPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeEfficiencyPolicyDelete(params *clientstorage.VolumeEfficiencyPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeEfficiencyPolicyDelete")
	}

	var r0 *clientstorage.VolumeEfficiencyPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeEfficiencyPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeEfficiencyPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeEfficiencyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeEfficiencyPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeEfficiencyPolicyGet(params *clientstorage.VolumeEfficiencyPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeEfficiencyPolicyGet")
	}

	var r0 *clientstorage.VolumeEfficiencyPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeEfficiencyPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeEfficiencyPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeEfficiencyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeEfficiencyPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeEfficiencyPolicyModify(params *clientstorage.VolumeEfficiencyPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeEfficiencyPolicyModify")
	}

	var r0 *clientstorage.VolumeEfficiencyPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeEfficiencyPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeEfficiencyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeEfficiencyPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeEfficiencyPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeEfficiencyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeGet(params *clientstorage.VolumeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeGet")
	}

	var r0 *clientstorage.VolumeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeMetricsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeMetricsCollectionGet(params *clientstorage.VolumeMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeMetricsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeMetricsCollectionGet")
	}

	var r0 *clientstorage.VolumeMetricsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeMetricsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeMetricsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeMetricsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VolumeModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VolumeModify(params *clientstorage.VolumeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientstorage.ClientOption) (*clientstorage.VolumeModifyOK, *clientstorage.VolumeModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VolumeModify")
	}

	var r0 *clientstorage.VolumeModifyOK
	var r1 *clientstorage.VolumeModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) (*clientstorage.VolumeModifyOK, *clientstorage.VolumeModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientstorage.VolumeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientstorage.VolumeModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientstorage.VolumeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) *clientstorage.VolumeModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientstorage.VolumeModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientstorage.VolumeModifyParams, runtime.ClientAuthInfoWriter, ...clientstorage.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
