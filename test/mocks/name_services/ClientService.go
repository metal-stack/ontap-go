// Code generated by mockery v2.52.3. DO NOT EDIT.

package name_services

import (
	clientname_services "github.com/metal-stack/ontap-go/api/client/name_services"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// DNSCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DNSCollectionGet(params *clientname_services.DNSCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.DNSCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DNSCollectionGet")
	}

	var r0 *clientname_services.DNSCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.DNSCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.DNSCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.DNSCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.DNSCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DNSCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DNSCreate(params *clientname_services.DNSCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.DNSCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DNSCreate")
	}

	var r0 *clientname_services.DNSCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.DNSCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.DNSCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.DNSCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.DNSCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DNSDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DNSDelete(params *clientname_services.DNSDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.DNSDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DNSDelete")
	}

	var r0 *clientname_services.DNSDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.DNSDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.DNSDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.DNSDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.DNSDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DNSGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DNSGet(params *clientname_services.DNSGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.DNSGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DNSGet")
	}

	var r0 *clientname_services.DNSGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.DNSGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.DNSGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.DNSGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.DNSGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DNSModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DNSModify(params *clientname_services.DNSModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.DNSModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DNSModify")
	}

	var r0 *clientname_services.DNSModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.DNSModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.DNSModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.DNSModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.DNSModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.DNSModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GlobalCacheSettingGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GlobalCacheSettingGet(params *clientname_services.GlobalCacheSettingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.GlobalCacheSettingGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GlobalCacheSettingGet")
	}

	var r0 *clientname_services.GlobalCacheSettingGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.GlobalCacheSettingGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.GlobalCacheSettingGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.GlobalCacheSettingGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.GlobalCacheSettingGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.GlobalCacheSettingGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.GlobalCacheSettingGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GlobalCacheSettingModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GlobalCacheSettingModify(params *clientname_services.GlobalCacheSettingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.GlobalCacheSettingModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GlobalCacheSettingModify")
	}

	var r0 *clientname_services.GlobalCacheSettingModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.GlobalCacheSettingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.GlobalCacheSettingModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.GlobalCacheSettingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.GlobalCacheSettingModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.GlobalCacheSettingModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.GlobalCacheSettingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupMembershipSettingsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupMembershipSettingsCollectionGet(params *clientname_services.GroupMembershipSettingsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupMembershipSettingsCollectionGet")
	}

	var r0 *clientname_services.GroupMembershipSettingsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.GroupMembershipSettingsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.GroupMembershipSettingsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.GroupMembershipSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupMembershipSettingsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupMembershipSettingsGet(params *clientname_services.GroupMembershipSettingsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupMembershipSettingsGet")
	}

	var r0 *clientname_services.GroupMembershipSettingsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.GroupMembershipSettingsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.GroupMembershipSettingsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.GroupMembershipSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupMembershipSettingsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupMembershipSettingsModify(params *clientname_services.GroupMembershipSettingsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupMembershipSettingsModify")
	}

	var r0 *clientname_services.GroupMembershipSettingsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.GroupMembershipSettingsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.GroupMembershipSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.GroupMembershipSettingsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.GroupMembershipSettingsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.GroupMembershipSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HostRecordGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HostRecordGet(params *clientname_services.HostRecordGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.HostRecordGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HostRecordGet")
	}

	var r0 *clientname_services.HostRecordGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.HostRecordGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.HostRecordGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.HostRecordGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.HostRecordGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.HostRecordGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.HostRecordGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HostsSettingsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HostsSettingsCollectionGet(params *clientname_services.HostsSettingsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.HostsSettingsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HostsSettingsCollectionGet")
	}

	var r0 *clientname_services.HostsSettingsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.HostsSettingsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.HostsSettingsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.HostsSettingsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.HostsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HostsSettingsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HostsSettingsGet(params *clientname_services.HostsSettingsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.HostsSettingsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HostsSettingsGet")
	}

	var r0 *clientname_services.HostsSettingsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.HostsSettingsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.HostsSettingsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.HostsSettingsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.HostsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HostsSettingsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HostsSettingsModify(params *clientname_services.HostsSettingsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.HostsSettingsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HostsSettingsModify")
	}

	var r0 *clientname_services.HostsSettingsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.HostsSettingsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.HostsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.HostsSettingsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.HostsSettingsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.HostsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapCollectionGet(params *clientname_services.LdapCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapCollectionGet")
	}

	var r0 *clientname_services.LdapCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapCreate(params *clientname_services.LdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapCreate")
	}

	var r0 *clientname_services.LdapCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapDelete(params *clientname_services.LdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapDelete")
	}

	var r0 *clientname_services.LdapDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapGet(params *clientname_services.LdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapGet")
	}

	var r0 *clientname_services.LdapGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapModify(params *clientname_services.LdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapModify")
	}

	var r0 *clientname_services.LdapModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapSchemaCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapSchemaCollectionGet(params *clientname_services.LdapSchemaCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapSchemaCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapSchemaCollectionGet")
	}

	var r0 *clientname_services.LdapSchemaCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapSchemaCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapSchemaCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapSchemaCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapSchemaCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapSchemaCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapSchemaCreate(params *clientname_services.LdapSchemaCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapSchemaCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapSchemaCreate")
	}

	var r0 *clientname_services.LdapSchemaCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapSchemaCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapSchemaCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapSchemaCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapSchemaCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapSchemaDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapSchemaDelete(params *clientname_services.LdapSchemaDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapSchemaDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapSchemaDelete")
	}

	var r0 *clientname_services.LdapSchemaDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapSchemaDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapSchemaDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapSchemaDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapSchemaDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapSchemaGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapSchemaGet(params *clientname_services.LdapSchemaGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapSchemaGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapSchemaGet")
	}

	var r0 *clientname_services.LdapSchemaGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapSchemaGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapSchemaGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapSchemaGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapSchemaGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LdapSchemaModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LdapSchemaModify(params *clientname_services.LdapSchemaModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LdapSchemaModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LdapSchemaModify")
	}

	var r0 *clientname_services.LdapSchemaModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LdapSchemaModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LdapSchemaModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LdapSchemaModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LdapSchemaModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LdapSchemaModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalHostCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalHostCollectionGet(params *clientname_services.LocalHostCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LocalHostCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalHostCollectionGet")
	}

	var r0 *clientname_services.LocalHostCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LocalHostCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LocalHostCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LocalHostCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LocalHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalHostCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalHostCreate(params *clientname_services.LocalHostCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LocalHostCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalHostCreate")
	}

	var r0 *clientname_services.LocalHostCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LocalHostCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LocalHostCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LocalHostCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LocalHostCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalHostDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalHostDelete(params *clientname_services.LocalHostDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LocalHostDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalHostDelete")
	}

	var r0 *clientname_services.LocalHostDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LocalHostDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LocalHostDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LocalHostDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LocalHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalHostGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalHostGet(params *clientname_services.LocalHostGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LocalHostGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalHostGet")
	}

	var r0 *clientname_services.LocalHostGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LocalHostGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LocalHostGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LocalHostGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LocalHostGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalHostModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalHostModify(params *clientname_services.LocalHostModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.LocalHostModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalHostModify")
	}

	var r0 *clientname_services.LocalHostModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.LocalHostModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.LocalHostModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.LocalHostModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.LocalHostModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.LocalHostModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NameMappingCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NameMappingCollectionGet(params *clientname_services.NameMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NameMappingCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NameMappingCollectionGet")
	}

	var r0 *clientname_services.NameMappingCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NameMappingCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NameMappingCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NameMappingCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NameMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NameMappingCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NameMappingCreate(params *clientname_services.NameMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NameMappingCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NameMappingCreate")
	}

	var r0 *clientname_services.NameMappingCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NameMappingCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NameMappingCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NameMappingCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NameMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NameMappingDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NameMappingDelete(params *clientname_services.NameMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NameMappingDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NameMappingDelete")
	}

	var r0 *clientname_services.NameMappingDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NameMappingDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NameMappingDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NameMappingDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NameMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NameMappingModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NameMappingModify(params *clientname_services.NameMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NameMappingModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NameMappingModify")
	}

	var r0 *clientname_services.NameMappingModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NameMappingModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NameMappingModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NameMappingModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NameMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NameMappingPositionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NameMappingPositionGet(params *clientname_services.NameMappingPositionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NameMappingPositionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NameMappingPositionGet")
	}

	var r0 *clientname_services.NameMappingPositionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingPositionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NameMappingPositionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NameMappingPositionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NameMappingPositionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NameMappingPositionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NameMappingPositionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetgroupFileDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetgroupFileDelete(params *clientname_services.NetgroupFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NetgroupFileDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetgroupFileDelete")
	}

	var r0 *clientname_services.NetgroupFileDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NetgroupFileDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NetgroupFileDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NetgroupFileDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NetgroupFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetgroupFileGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetgroupFileGet(params *clientname_services.NetgroupFileGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NetgroupFileGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetgroupFileGet")
	}

	var r0 *clientname_services.NetgroupFileGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupFileGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NetgroupFileGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupFileGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NetgroupFileGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NetgroupFileGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NetgroupFileGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetgroupsSettingsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetgroupsSettingsCollectionGet(params *clientname_services.NetgroupsSettingsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetgroupsSettingsCollectionGet")
	}

	var r0 *clientname_services.NetgroupsSettingsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NetgroupsSettingsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NetgroupsSettingsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NetgroupsSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetgroupsSettingsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetgroupsSettingsGet(params *clientname_services.NetgroupsSettingsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetgroupsSettingsGet")
	}

	var r0 *clientname_services.NetgroupsSettingsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NetgroupsSettingsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NetgroupsSettingsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NetgroupsSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetgroupsSettingsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetgroupsSettingsModify(params *clientname_services.NetgroupsSettingsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetgroupsSettingsModify")
	}

	var r0 *clientname_services.NetgroupsSettingsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NetgroupsSettingsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NetgroupsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NetgroupsSettingsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NetgroupsSettingsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NetgroupsSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NisCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NisCollectionGet(params *clientname_services.NisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NisCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NisCollectionGet")
	}

	var r0 *clientname_services.NisCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NisCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NisCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NisCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NisCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NisCreate(params *clientname_services.NisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NisCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NisCreate")
	}

	var r0 *clientname_services.NisCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NisCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NisCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NisCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NisCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NisCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NisCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NisDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NisDelete(params *clientname_services.NisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NisDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NisDelete")
	}

	var r0 *clientname_services.NisDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NisDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NisDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NisDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NisDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NisDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NisDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NisGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NisGet(params *clientname_services.NisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NisGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NisGet")
	}

	var r0 *clientname_services.NisGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NisGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NisGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NisGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NisGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NisGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NisGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NisModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NisModify(params *clientname_services.NisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.NisModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NisModify")
	}

	var r0 *clientname_services.NisModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.NisModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.NisModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.NisModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.NisModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.NisModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.NisModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// UnixGroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupCollectionGet(params *clientname_services.UnixGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupCollectionGet")
	}

	var r0 *clientname_services.UnixGroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupCreate(params *clientname_services.UnixGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupCreate")
	}

	var r0 *clientname_services.UnixGroupCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupDelete(params *clientname_services.UnixGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupDelete")
	}

	var r0 *clientname_services.UnixGroupDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupGet(params *clientname_services.UnixGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupGet")
	}

	var r0 *clientname_services.UnixGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupModify(params *clientname_services.UnixGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupModify")
	}

	var r0 *clientname_services.UnixGroupModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupSettingsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupSettingsCollectionGet(params *clientname_services.UnixGroupSettingsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupSettingsCollectionGet")
	}

	var r0 *clientname_services.UnixGroupSettingsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupSettingsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupSettingsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupSettingsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupSettingsGet(params *clientname_services.UnixGroupSettingsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupSettingsGet")
	}

	var r0 *clientname_services.UnixGroupSettingsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupSettingsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupSettingsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupSettingsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupSettingsModify(params *clientname_services.UnixGroupSettingsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupSettingsModify")
	}

	var r0 *clientname_services.UnixGroupSettingsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupSettingsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupSettingsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupSettingsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupUserDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupUserDelete(params *clientname_services.UnixGroupUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupUserDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupUserDelete")
	}

	var r0 *clientname_services.UnixGroupUserDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupUserDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupUserDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupUserDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupUsersCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupUsersCollectionGet(params *clientname_services.UnixGroupUsersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupUsersCollectionGet")
	}

	var r0 *clientname_services.UnixGroupUsersCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupUsersCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupUsersCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupUsersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupUsersCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupUsersCreate(params *clientname_services.UnixGroupUsersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupUsersCreate")
	}

	var r0 *clientname_services.UnixGroupUsersCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupUsersCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupUsersCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupUsersCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixGroupUsersGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixGroupUsersGet(params *clientname_services.UnixGroupUsersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixGroupUsersGet")
	}

	var r0 *clientname_services.UnixGroupUsersGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixGroupUsersGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixGroupUsersGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixGroupUsersGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixGroupUsersGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixGroupUsersGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserCollectionGet(params *clientname_services.UnixUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserCollectionGet")
	}

	var r0 *clientname_services.UnixUserCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserCreate(params *clientname_services.UnixUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserCreate")
	}

	var r0 *clientname_services.UnixUserCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserCreateParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserDelete(params *clientname_services.UnixUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserDelete")
	}

	var r0 *clientname_services.UnixUserDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserGet(params *clientname_services.UnixUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserGet")
	}

	var r0 *clientname_services.UnixUserGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserModify(params *clientname_services.UnixUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserModify")
	}

	var r0 *clientname_services.UnixUserModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserSettingsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserSettingsCollectionGet(params *clientname_services.UnixUserSettingsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserSettingsCollectionGet")
	}

	var r0 *clientname_services.UnixUserSettingsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserSettingsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserSettingsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserSettingsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserSettingsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserSettingsGet(params *clientname_services.UnixUserSettingsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserSettingsGet")
	}

	var r0 *clientname_services.UnixUserSettingsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserSettingsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserSettingsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserSettingsGetParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnixUserSettingsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UnixUserSettingsModify(params *clientname_services.UnixUserSettingsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnixUserSettingsModify")
	}

	var r0 *clientname_services.UnixUserSettingsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) (*clientname_services.UnixUserSettingsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientname_services.UnixUserSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) *clientname_services.UnixUserSettingsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientname_services.UnixUserSettingsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientname_services.UnixUserSettingsModifyParams, runtime.ClientAuthInfoWriter, ...clientname_services.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
