// Code generated by mockery v2.52.3. DO NOT EDIT.

package cluster

import (
	clientcluster "github.com/metal-stack/ontap-go/api/client/cluster"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// CapacityPoolCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CapacityPoolCollectionGet(params *clientcluster.CapacityPoolCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CapacityPoolCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CapacityPoolCollectionGet")
	}

	var r0 *clientcluster.CapacityPoolCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CapacityPoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CapacityPoolCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CapacityPoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CapacityPoolCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CapacityPoolCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CapacityPoolCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapacityPoolGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CapacityPoolGet(params *clientcluster.CapacityPoolGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CapacityPoolGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CapacityPoolGet")
	}

	var r0 *clientcluster.CapacityPoolGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CapacityPoolGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CapacityPoolGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CapacityPoolGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CapacityPoolGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CapacityPoolGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CapacityPoolGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChassisCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ChassisCollectionGet(params *clientcluster.ChassisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ChassisCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChassisCollectionGet")
	}

	var r0 *clientcluster.ChassisCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ChassisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ChassisCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ChassisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ChassisCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ChassisCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ChassisCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChassisGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ChassisGet(params *clientcluster.ChassisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ChassisGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChassisGet")
	}

	var r0 *clientcluster.ChassisGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ChassisGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ChassisGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ChassisGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ChassisGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ChassisGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ChassisGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterCollectionPerformanceMetricsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterCollectionPerformanceMetricsGet(params *clientcluster.ClusterCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterCollectionPerformanceMetricsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCollectionPerformanceMetricsGet")
	}

	var r0 *clientcluster.ClusterCollectionPerformanceMetricsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterCollectionPerformanceMetricsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterCollectionPerformanceMetricsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterCollectionPerformanceMetricsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterCreate(params *clientcluster.ClusterCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterCreateCreated, *clientcluster.ClusterCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCreate")
	}

	var r0 *clientcluster.ClusterCreateCreated
	var r1 *clientcluster.ClusterCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterCreateCreated, *clientcluster.ClusterCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.ClusterCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.ClusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterGet(params *clientcluster.ClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGet")
	}

	var r0 *clientcluster.ClusterGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterModify(params *clientcluster.ClusterModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterModifyOK, *clientcluster.ClusterModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterModify")
	}

	var r0 *clientcluster.ClusterModifyOK
	var r1 *clientcluster.ClusterModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterModifyOK, *clientcluster.ClusterModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.ClusterModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.ClusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterNtpKeysCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpKeysCollectionGet(params *clientcluster.ClusterNtpKeysCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpKeysCollectionGet")
	}

	var r0 *clientcluster.ClusterNtpKeysCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpKeysCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpKeysCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpKeysCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpKeysCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpKeysCreate(params *clientcluster.ClusterNtpKeysCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpKeysCreate")
	}

	var r0 *clientcluster.ClusterNtpKeysCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpKeysCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpKeysCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpKeysCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpKeysDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpKeysDelete(params *clientcluster.ClusterNtpKeysDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpKeysDelete")
	}

	var r0 *clientcluster.ClusterNtpKeysDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpKeysDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpKeysDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpKeysDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpKeysGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpKeysGet(params *clientcluster.ClusterNtpKeysGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpKeysGet")
	}

	var r0 *clientcluster.ClusterNtpKeysGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpKeysGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpKeysGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpKeysGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpKeysModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpKeysModify(params *clientcluster.ClusterNtpKeysModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpKeysModify")
	}

	var r0 *clientcluster.ClusterNtpKeysModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpKeysModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpKeysModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpKeysModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpKeysModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpKeysModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpServersCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpServersCollectionGet(params *clientcluster.ClusterNtpServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpServersCollectionGet")
	}

	var r0 *clientcluster.ClusterNtpServersCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpServersCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpServersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpServersCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpServersCreate(params *clientcluster.ClusterNtpServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersCreateCreated, *clientcluster.ClusterNtpServersCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpServersCreate")
	}

	var r0 *clientcluster.ClusterNtpServersCreateCreated
	var r1 *clientcluster.ClusterNtpServersCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersCreateCreated, *clientcluster.ClusterNtpServersCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpServersCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpServersCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.ClusterNtpServersCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.ClusterNtpServersCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterNtpServersDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpServersDelete(params *clientcluster.ClusterNtpServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersDeleteOK, *clientcluster.ClusterNtpServersDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpServersDelete")
	}

	var r0 *clientcluster.ClusterNtpServersDeleteOK
	var r1 *clientcluster.ClusterNtpServersDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersDeleteOK, *clientcluster.ClusterNtpServersDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpServersDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.ClusterNtpServersDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.ClusterNtpServersDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterNtpServersGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpServersGet(params *clientcluster.ClusterNtpServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpServersGet")
	}

	var r0 *clientcluster.ClusterNtpServersGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpServersGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpServersGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterNtpServersModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterNtpServersModify(params *clientcluster.ClusterNtpServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersModifyOK, *clientcluster.ClusterNtpServersModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNtpServersModify")
	}

	var r0 *clientcluster.ClusterNtpServersModifyOK
	var r1 *clientcluster.ClusterNtpServersModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterNtpServersModifyOK, *clientcluster.ClusterNtpServersModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterNtpServersModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterNtpServersModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterNtpServersModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterNtpServersModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.ClusterNtpServersModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.ClusterNtpServersModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClusterPeerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterPeerCollectionGet(params *clientcluster.ClusterPeerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterPeerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterPeerCollectionGet")
	}

	var r0 *clientcluster.ClusterPeerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterPeerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterPeerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterPeerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterPeerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterPeerCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterPeerCreate(params *clientcluster.ClusterPeerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterPeerCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterPeerCreate")
	}

	var r0 *clientcluster.ClusterPeerCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterPeerCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterPeerCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterPeerCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterPeerCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterPeerDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterPeerDelete(params *clientcluster.ClusterPeerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterPeerDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterPeerDelete")
	}

	var r0 *clientcluster.ClusterPeerDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterPeerDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterPeerDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterPeerDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterPeerDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterPeerGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterPeerGet(params *clientcluster.ClusterPeerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterPeerGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterPeerGet")
	}

	var r0 *clientcluster.ClusterPeerGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterPeerGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterPeerGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterPeerGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterPeerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClusterPeerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClusterPeerModify(params *clientcluster.ClusterPeerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ClusterPeerModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterPeerModify")
	}

	var r0 *clientcluster.ClusterPeerModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ClusterPeerModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ClusterPeerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ClusterPeerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ClusterPeerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ClusterPeerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CounterRowCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CounterRowCollectionGet(params *clientcluster.CounterRowCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CounterRowCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CounterRowCollectionGet")
	}

	var r0 *clientcluster.CounterRowCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterRowCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CounterRowCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterRowCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CounterRowCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CounterRowCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CounterRowCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CounterRowGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CounterRowGet(params *clientcluster.CounterRowGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CounterRowGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CounterRowGet")
	}

	var r0 *clientcluster.CounterRowGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterRowGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CounterRowGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterRowGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CounterRowGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CounterRowGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CounterRowGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CounterTableCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CounterTableCollectionGet(params *clientcluster.CounterTableCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CounterTableCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CounterTableCollectionGet")
	}

	var r0 *clientcluster.CounterTableCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterTableCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CounterTableCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterTableCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CounterTableCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CounterTableCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CounterTableCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CounterTableGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CounterTableGet(params *clientcluster.CounterTableGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.CounterTableGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CounterTableGet")
	}

	var r0 *clientcluster.CounterTableGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterTableGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.CounterTableGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.CounterTableGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.CounterTableGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.CounterTableGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.CounterTableGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FirmwareHistoryCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FirmwareHistoryCollectionGet(params *clientcluster.FirmwareHistoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.FirmwareHistoryCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareHistoryCollectionGet")
	}

	var r0 *clientcluster.FirmwareHistoryCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.FirmwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.FirmwareHistoryCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.FirmwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.FirmwareHistoryCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.FirmwareHistoryCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.FirmwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JobCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) JobCollectionGet(params *clientcluster.JobCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.JobCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JobCollectionGet")
	}

	var r0 *clientcluster.JobCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.JobCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.JobCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.JobCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.JobCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.JobCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.JobCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JobGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) JobGet(params *clientcluster.JobGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.JobGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JobGet")
	}

	var r0 *clientcluster.JobGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.JobGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.JobGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.JobGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.JobGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.JobGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.JobGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JobModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) JobModify(params *clientcluster.JobModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.JobModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JobModify")
	}

	var r0 *clientcluster.JobModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.JobModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.JobModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.JobModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.JobModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.JobModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.JobModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseCreate(params *clientcluster.LicenseCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseCreate")
	}

	var r0 *clientcluster.LicenseCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseDelete(params *clientcluster.LicenseDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseDelete")
	}

	var r0 *clientcluster.LicenseDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseGet(params *clientcluster.LicenseGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseGet")
	}

	var r0 *clientcluster.LicenseGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseManagerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseManagerCollectionGet(params *clientcluster.LicenseManagerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseManagerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseManagerCollectionGet")
	}

	var r0 *clientcluster.LicenseManagerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseManagerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseManagerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseManagerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseManagerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseManagerGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseManagerGet(params *clientcluster.LicenseManagerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseManagerGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseManagerGet")
	}

	var r0 *clientcluster.LicenseManagerGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseManagerGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseManagerGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseManagerGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseManagerGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LicenseManagerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicenseManagerModify(params *clientcluster.LicenseManagerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicenseManagerModifyOK, *clientcluster.LicenseManagerModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicenseManagerModify")
	}

	var r0 *clientcluster.LicenseManagerModifyOK
	var r1 *clientcluster.LicenseManagerModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicenseManagerModifyOK, *clientcluster.LicenseManagerModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicenseManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseManagerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicenseManagerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicenseManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicenseManagerModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.LicenseManagerModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.LicenseManagerModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LicensesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LicensesGet(params *clientcluster.LicensesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.LicensesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LicensesGet")
	}

	var r0 *clientcluster.LicensesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.LicensesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.LicensesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.LicensesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.LicensesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.LicensesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.LicensesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MediatorCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MediatorCollectionGet(params *clientcluster.MediatorCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MediatorCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MediatorCollectionGet")
	}

	var r0 *clientcluster.MediatorCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MediatorCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MediatorCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MediatorCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MediatorCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MediatorCreate(params *clientcluster.MediatorCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MediatorCreateCreated, *clientcluster.MediatorCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MediatorCreate")
	}

	var r0 *clientcluster.MediatorCreateCreated
	var r1 *clientcluster.MediatorCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MediatorCreateCreated, *clientcluster.MediatorCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MediatorCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MediatorCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MediatorCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MediatorCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MediatorDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MediatorDelete(params *clientcluster.MediatorDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MediatorDeleteOK, *clientcluster.MediatorDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MediatorDelete")
	}

	var r0 *clientcluster.MediatorDeleteOK
	var r1 *clientcluster.MediatorDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MediatorDeleteOK, *clientcluster.MediatorDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MediatorDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MediatorDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MediatorDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MediatorDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MediatorGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MediatorGet(params *clientcluster.MediatorGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MediatorGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MediatorGet")
	}

	var r0 *clientcluster.MediatorGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MediatorGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MediatorGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MediatorGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MediatorGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MediatorGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterCreate(params *clientcluster.MetroclusterCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterCreateCreated, *clientcluster.MetroclusterCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterCreate")
	}

	var r0 *clientcluster.MetroclusterCreateCreated
	var r1 *clientcluster.MetroclusterCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterCreateCreated, *clientcluster.MetroclusterCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterDiagnosticsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDiagnosticsCreate(params *clientcluster.MetroclusterDiagnosticsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDiagnosticsCreateCreated, *clientcluster.MetroclusterDiagnosticsCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDiagnosticsCreate")
	}

	var r0 *clientcluster.MetroclusterDiagnosticsCreateCreated
	var r1 *clientcluster.MetroclusterDiagnosticsCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDiagnosticsCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDiagnosticsCreateCreated, *clientcluster.MetroclusterDiagnosticsCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDiagnosticsCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDiagnosticsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDiagnosticsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDiagnosticsCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDiagnosticsCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterDiagnosticsCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterDiagnosticsCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterDiagnosticsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDiagnosticsGet(params *clientcluster.MetroclusterDiagnosticsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDiagnosticsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDiagnosticsGet")
	}

	var r0 *clientcluster.MetroclusterDiagnosticsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDiagnosticsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDiagnosticsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDiagnosticsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDiagnosticsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDiagnosticsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDiagnosticsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterDrGroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDrGroupCollectionGet(params *clientcluster.MetroclusterDrGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDrGroupCollectionGet")
	}

	var r0 *clientcluster.MetroclusterDrGroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDrGroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDrGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterDrGroupCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDrGroupCreate(params *clientcluster.MetroclusterDrGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupCreateCreated, *clientcluster.MetroclusterDrGroupCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDrGroupCreate")
	}

	var r0 *clientcluster.MetroclusterDrGroupCreateCreated
	var r1 *clientcluster.MetroclusterDrGroupCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupCreateCreated, *clientcluster.MetroclusterDrGroupCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDrGroupCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDrGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterDrGroupCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterDrGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterDrGroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDrGroupDelete(params *clientcluster.MetroclusterDrGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupDeleteOK, *clientcluster.MetroclusterDrGroupDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDrGroupDelete")
	}

	var r0 *clientcluster.MetroclusterDrGroupDeleteOK
	var r1 *clientcluster.MetroclusterDrGroupDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupDeleteOK, *clientcluster.MetroclusterDrGroupDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDrGroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDrGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterDrGroupDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterDrGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterDrGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterDrGroupGet(params *clientcluster.MetroclusterDrGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterDrGroupGet")
	}

	var r0 *clientcluster.MetroclusterDrGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterDrGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterDrGroupGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterDrGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterDrGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterDrGroupGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterGet(params *clientcluster.MetroclusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterGet")
	}

	var r0 *clientcluster.MetroclusterGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterInterconnectCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterInterconnectCollectionGet(params *clientcluster.MetroclusterInterconnectCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterInterconnectCollectionGet")
	}

	var r0 *clientcluster.MetroclusterInterconnectCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterInterconnectCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterInterconnectCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterInterconnectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterInterconnectGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterInterconnectGet(params *clientcluster.MetroclusterInterconnectGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterInterconnectGet")
	}

	var r0 *clientcluster.MetroclusterInterconnectGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterInterconnectGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterInterconnectGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterInterconnectGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterInterconnectModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterInterconnectModify(params *clientcluster.MetroclusterInterconnectModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectModifyOK, *clientcluster.MetroclusterInterconnectModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterInterconnectModify")
	}

	var r0 *clientcluster.MetroclusterInterconnectModifyOK
	var r1 *clientcluster.MetroclusterInterconnectModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterInterconnectModifyOK, *clientcluster.MetroclusterInterconnectModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterInterconnectModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterInterconnectModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterInterconnectModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterInterconnectModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterInterconnectModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterInterconnectModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterInterconnectModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterModify(params *clientcluster.MetroclusterModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterModifyOK, *clientcluster.MetroclusterModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterModify")
	}

	var r0 *clientcluster.MetroclusterModifyOK
	var r1 *clientcluster.MetroclusterModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterModifyOK, *clientcluster.MetroclusterModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.MetroclusterModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.MetroclusterModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MetroclusterNodeCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterNodeCollectionGet(params *clientcluster.MetroclusterNodeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterNodeCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterNodeCollectionGet")
	}

	var r0 *clientcluster.MetroclusterNodeCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterNodeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterNodeCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterNodeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterNodeCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterNodeCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterNodeCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterNodeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterNodeGet(params *clientcluster.MetroclusterNodeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterNodeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterNodeGet")
	}

	var r0 *clientcluster.MetroclusterNodeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterNodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterNodeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterNodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterNodeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterNodeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterNodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterOperationCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterOperationCollectionGet(params *clientcluster.MetroclusterOperationCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterOperationCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterOperationCollectionGet")
	}

	var r0 *clientcluster.MetroclusterOperationCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterOperationCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterOperationCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterOperationCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterOperationCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterOperationGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterOperationGet(params *clientcluster.MetroclusterOperationGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterOperationGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterOperationGet")
	}

	var r0 *clientcluster.MetroclusterOperationGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterOperationGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterOperationGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterOperationGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterOperationGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterOperationGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterOperationGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterSvmCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterSvmCollectionGet(params *clientcluster.MetroclusterSvmCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterSvmCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterSvmCollectionGet")
	}

	var r0 *clientcluster.MetroclusterSvmCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterSvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterSvmCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterSvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterSvmCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterSvmCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterSvmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetroclusterSvmGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MetroclusterSvmGet(params *clientcluster.MetroclusterSvmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.MetroclusterSvmGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MetroclusterSvmGet")
	}

	var r0 *clientcluster.MetroclusterSvmGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterSvmGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.MetroclusterSvmGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.MetroclusterSvmGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.MetroclusterSvmGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.MetroclusterSvmGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.MetroclusterSvmGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodeDelete(params *clientcluster.NodeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodeDeleteOK, *clientcluster.NodeDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodeDelete")
	}

	var r0 *clientcluster.NodeDeleteOK
	var r1 *clientcluster.NodeDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodeDeleteOK, *clientcluster.NodeDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodeDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodeDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.NodeDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.NodeDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NodeGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodeGet(params *clientcluster.NodeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodeGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodeGet")
	}

	var r0 *clientcluster.NodeGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodeGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodeGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodeGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeMetricsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodeMetricsCollectionGet(params *clientcluster.NodeMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodeMetricsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodeMetricsCollectionGet")
	}

	var r0 *clientcluster.NodeMetricsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodeMetricsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeMetricsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodeMetricsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodeMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodeModify(params *clientcluster.NodeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodeModifyOK, *clientcluster.NodeModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodeModify")
	}

	var r0 *clientcluster.NodeModifyOK
	var r1 *clientcluster.NodeModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodeModifyOK, *clientcluster.NodeModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodeModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodeModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodeModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodeModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.NodeModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.NodeModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NodesCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodesCreate(params *clientcluster.NodesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodesCreateCreated, *clientcluster.NodesCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodesCreate")
	}

	var r0 *clientcluster.NodesCreateCreated
	var r1 *clientcluster.NodesCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodesCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodesCreateCreated, *clientcluster.NodesCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodesCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodesCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodesCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodesCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodesCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.NodesCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.NodesCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NodesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NodesGet(params *clientcluster.NodesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.NodesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodesGet")
	}

	var r0 *clientcluster.NodesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.NodesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.NodesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.NodesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.NodesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.NodesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.NodesGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagCollectionGet(params *clientcluster.ResourceTagCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagCollectionGet")
	}

	var r0 *clientcluster.ResourceTagCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagGet(params *clientcluster.ResourceTagGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagGet")
	}

	var r0 *clientcluster.ResourceTagGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagResourceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagResourceCollectionGet(params *clientcluster.ResourceTagResourceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagResourceCollectionGet")
	}

	var r0 *clientcluster.ResourceTagResourceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagResourceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagResourceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagResourceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagResourceCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagResourceCreate(params *clientcluster.ResourceTagResourceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagResourceCreate")
	}

	var r0 *clientcluster.ResourceTagResourceCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagResourceCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagResourceCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagResourceCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagResourceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagResourceDelete(params *clientcluster.ResourceTagResourceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagResourceDelete")
	}

	var r0 *clientcluster.ResourceTagResourceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagResourceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagResourceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagResourceDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceTagResourceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ResourceTagResourceGet(params *clientcluster.ResourceTagResourceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResourceTagResourceGet")
	}

	var r0 *clientcluster.ResourceTagResourceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ResourceTagResourceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ResourceTagResourceGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ResourceTagResourceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ResourceTagResourceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ResourceTagResourceGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ScheduleCollectionGet(params *clientcluster.ScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ScheduleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleCollectionGet")
	}

	var r0 *clientcluster.ScheduleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ScheduleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ScheduleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ScheduleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ScheduleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ScheduleCreate(params *clientcluster.ScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ScheduleCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleCreate")
	}

	var r0 *clientcluster.ScheduleCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ScheduleCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ScheduleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ScheduleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ScheduleCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ScheduleDelete(params *clientcluster.ScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ScheduleDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleDelete")
	}

	var r0 *clientcluster.ScheduleDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ScheduleDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ScheduleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ScheduleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ScheduleDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ScheduleGet(params *clientcluster.ScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ScheduleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleGet")
	}

	var r0 *clientcluster.ScheduleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ScheduleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ScheduleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ScheduleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ScheduleGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ScheduleModify(params *clientcluster.ScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.ScheduleModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleModify")
	}

	var r0 *clientcluster.ScheduleModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.ScheduleModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.ScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.ScheduleModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.ScheduleModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.ScheduleModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SensorsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SensorsCollectionGet(params *clientcluster.SensorsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SensorsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SensorsCollectionGet")
	}

	var r0 *clientcluster.SensorsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SensorsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SensorsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SensorsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SensorsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SensorsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SensorsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SensorsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SensorsGet(params *clientcluster.SensorsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SensorsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SensorsGet")
	}

	var r0 *clientcluster.SensorsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SensorsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SensorsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SensorsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SensorsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SensorsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SensorsGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// SoftwareDownloadGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwareDownloadGet(params *clientcluster.SoftwareDownloadGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwareDownloadGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwareDownloadGet")
	}

	var r0 *clientcluster.SoftwareDownloadGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareDownloadGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwareDownloadGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareDownloadGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareDownloadGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwareDownloadGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwareDownloadGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SoftwareGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwareGet(params *clientcluster.SoftwareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwareGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwareGet")
	}

	var r0 *clientcluster.SoftwareGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwareGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwareGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwareGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SoftwareHistoryCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwareHistoryCollectionGet(params *clientcluster.SoftwareHistoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwareHistoryCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwareHistoryCollectionGet")
	}

	var r0 *clientcluster.SoftwareHistoryCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwareHistoryCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareHistoryCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwareHistoryCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwareHistoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SoftwareModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwareModify(params *clientcluster.SoftwareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwareModifyOK, *clientcluster.SoftwareModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwareModify")
	}

	var r0 *clientcluster.SoftwareModifyOK
	var r1 *clientcluster.SoftwareModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwareModifyOK, *clientcluster.SoftwareModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwareModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwareModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.SoftwareModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.SoftwareModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SoftwarePackageCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwarePackageCreate(params *clientcluster.SoftwarePackageCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageCreateCreated, *clientcluster.SoftwarePackageCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwarePackageCreate")
	}

	var r0 *clientcluster.SoftwarePackageCreateCreated
	var r1 *clientcluster.SoftwarePackageCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageCreateCreated, *clientcluster.SoftwarePackageCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackageCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwarePackageCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwarePackageCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackageCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.SoftwarePackageCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.SoftwarePackageCreateParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SoftwarePackageDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwarePackageDelete(params *clientcluster.SoftwarePackageDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageDeleteOK, *clientcluster.SoftwarePackageDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwarePackageDelete")
	}

	var r0 *clientcluster.SoftwarePackageDeleteOK
	var r1 *clientcluster.SoftwarePackageDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageDeleteOK, *clientcluster.SoftwarePackageDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackageDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwarePackageDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwarePackageDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackageDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.SoftwarePackageDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.SoftwarePackageDeleteParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SoftwarePackageGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwarePackageGet(params *clientcluster.SoftwarePackageGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwarePackageGet")
	}

	var r0 *clientcluster.SoftwarePackageGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwarePackageGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackageGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackageGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwarePackageGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwarePackageGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SoftwarePackagesCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwarePackagesCollectionGet(params *clientcluster.SoftwarePackagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwarePackagesCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwarePackagesCollectionGet")
	}

	var r0 *clientcluster.SoftwarePackagesCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwarePackagesCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwarePackagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwarePackagesCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwarePackagesCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwarePackagesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SoftwareUpload provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SoftwareUpload(params *clientcluster.SoftwareUploadParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.SoftwareUploadCreated, *clientcluster.SoftwareUploadAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftwareUpload")
	}

	var r0 *clientcluster.SoftwareUploadCreated
	var r1 *clientcluster.SoftwareUploadAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareUploadParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.SoftwareUploadCreated, *clientcluster.SoftwareUploadAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.SoftwareUploadParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareUploadCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.SoftwareUploadCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.SoftwareUploadParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.SoftwareUploadAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.SoftwareUploadAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.SoftwareUploadParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// WebGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) WebGet(params *clientcluster.WebGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.WebGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebGet")
	}

	var r0 *clientcluster.WebGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientcluster.WebGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.WebGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.WebGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.WebGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.WebGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.WebGetParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) WebModify(params *clientcluster.WebModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientcluster.ClientOption) (*clientcluster.WebModifyOK, *clientcluster.WebModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebModify")
	}

	var r0 *clientcluster.WebModifyOK
	var r1 *clientcluster.WebModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientcluster.WebModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) (*clientcluster.WebModifyOK, *clientcluster.WebModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientcluster.WebModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.WebModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientcluster.WebModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientcluster.WebModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) *clientcluster.WebModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientcluster.WebModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientcluster.WebModifyParams, runtime.ClientAuthInfoWriter, ...clientcluster.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
