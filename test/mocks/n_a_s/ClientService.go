// Code generated by mockery v2.51.0. DO NOT EDIT.

package n_a_s

import (
	clientn_a_s "github.com/metal-stack/ontap-go/api/client/n_a_s"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// ActiveDirectoryCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryCollectionGet(params *clientn_a_s.ActiveDirectoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryCollectionGet")
	}

	var r0 *clientn_a_s.ActiveDirectoryCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryCreate(params *clientn_a_s.ActiveDirectoryCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryCreate")
	}

	var r0 *clientn_a_s.ActiveDirectoryCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryDelete(params *clientn_a_s.ActiveDirectoryDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryDelete")
	}

	var r0 *clientn_a_s.ActiveDirectoryDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryGet(params *clientn_a_s.ActiveDirectoryGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryGet")
	}

	var r0 *clientn_a_s.ActiveDirectoryGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryModify(params *clientn_a_s.ActiveDirectoryModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryModify")
	}

	var r0 *clientn_a_s.ActiveDirectoryModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryPreferredDcCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryPreferredDcCollectionGet(params *clientn_a_s.ActiveDirectoryPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryPreferredDcCollectionGet")
	}

	var r0 *clientn_a_s.ActiveDirectoryPreferredDcCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryPreferredDcCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryPreferredDcCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryPreferredDcCreate(params *clientn_a_s.ActiveDirectoryPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryPreferredDcCreate")
	}

	var r0 *clientn_a_s.ActiveDirectoryPreferredDcCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryPreferredDcCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryPreferredDcCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryPreferredDcDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryPreferredDcDelete(params *clientn_a_s.ActiveDirectoryPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryPreferredDcDelete")
	}

	var r0 *clientn_a_s.ActiveDirectoryPreferredDcDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryPreferredDcDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryPreferredDcDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveDirectoryPreferredDcGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ActiveDirectoryPreferredDcGet(params *clientn_a_s.ActiveDirectoryPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActiveDirectoryPreferredDcGet")
	}

	var r0 *clientn_a_s.ActiveDirectoryPreferredDcGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ActiveDirectoryPreferredDcGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ActiveDirectoryPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ActiveDirectoryPreferredDcGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ActiveDirectoryPreferredDcGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ActiveDirectoryPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuditCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditCollectionGet(params *clientn_a_s.AuditCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.AuditCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditCollectionGet")
	}

	var r0 *clientn_a_s.AuditCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.AuditCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.AuditCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.AuditCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuditCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditCreate(params *clientn_a_s.AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.AuditCreateCreated, *clientn_a_s.AuditCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditCreate")
	}

	var r0 *clientn_a_s.AuditCreateCreated
	var r1 *clientn_a_s.AuditCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.AuditCreateCreated, *clientn_a_s.AuditCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.AuditCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.AuditCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AuditDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditDelete(params *clientn_a_s.AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.AuditDeleteOK, *clientn_a_s.AuditDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditDelete")
	}

	var r0 *clientn_a_s.AuditDeleteOK
	var r1 *clientn_a_s.AuditDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.AuditDeleteOK, *clientn_a_s.AuditDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.AuditDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.AuditDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AuditGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditGet(params *clientn_a_s.AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.AuditGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditGet")
	}

	var r0 *clientn_a_s.AuditGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.AuditGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.AuditGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuditModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AuditModify(params *clientn_a_s.AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.AuditModifyOK, *clientn_a_s.AuditModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditModify")
	}

	var r0 *clientn_a_s.AuditModifyOK
	var r1 *clientn_a_s.AuditModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.AuditModifyOK, *clientn_a_s.AuditModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.AuditModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.AuditModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.AuditModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CifsCollectionPerformanceMetricsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsCollectionPerformanceMetricsGet(params *clientn_a_s.CifsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsCollectionPerformanceMetricsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsCollectionPerformanceMetricsGet")
	}

	var r0 *clientn_a_s.CifsCollectionPerformanceMetricsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsCollectionPerformanceMetricsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsCollectionPerformanceMetricsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsCollectionPerformanceMetricsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsConnectionCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsConnectionCollectionGet(params *clientn_a_s.CifsConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsConnectionCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsConnectionCollectionGet")
	}

	var r0 *clientn_a_s.CifsConnectionCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsConnectionCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsConnectionCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsConnectionCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainCollectionGet(params *clientn_a_s.CifsDomainCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainCollectionGet")
	}

	var r0 *clientn_a_s.CifsDomainCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainGet(params *clientn_a_s.CifsDomainGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainGet")
	}

	var r0 *clientn_a_s.CifsDomainGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainModify(params *clientn_a_s.CifsDomainModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainModify")
	}

	var r0 *clientn_a_s.CifsDomainModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainPreferredDcCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainPreferredDcCollectionGet(params *clientn_a_s.CifsDomainPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainPreferredDcCollectionGet")
	}

	var r0 *clientn_a_s.CifsDomainPreferredDcCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainPreferredDcCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainPreferredDcCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainPreferredDcCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainPreferredDcCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainPreferredDcCreate(params *clientn_a_s.CifsDomainPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainPreferredDcCreate")
	}

	var r0 *clientn_a_s.CifsDomainPreferredDcCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainPreferredDcCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainPreferredDcCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainPreferredDcCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainPreferredDcDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainPreferredDcDelete(params *clientn_a_s.CifsDomainPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainPreferredDcDelete")
	}

	var r0 *clientn_a_s.CifsDomainPreferredDcDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainPreferredDcDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainPreferredDcDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainPreferredDcDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsDomainPreferredDcGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsDomainPreferredDcGet(params *clientn_a_s.CifsDomainPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsDomainPreferredDcGet")
	}

	var r0 *clientn_a_s.CifsDomainPreferredDcGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsDomainPreferredDcGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsDomainPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsDomainPreferredDcGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsDomainPreferredDcGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsDomainPreferredDcGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsHomedirSearchPathGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsHomedirSearchPathGet(params *clientn_a_s.CifsHomedirSearchPathGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsHomedirSearchPathGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsHomedirSearchPathGet")
	}

	var r0 *clientn_a_s.CifsHomedirSearchPathGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsHomedirSearchPathGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsHomedirSearchPathGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsHomedirSearchPathGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsHomedirSearchPathGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsHomedirSearchPathGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsHomedirSearchPathGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsOpenFileCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsOpenFileCollectionGet(params *clientn_a_s.CifsOpenFileCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsOpenFileCollectionGet")
	}

	var r0 *clientn_a_s.CifsOpenFileCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsOpenFileCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsOpenFileCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsOpenFileCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsOpenFileDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsOpenFileDelete(params *clientn_a_s.CifsOpenFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsOpenFileDelete")
	}

	var r0 *clientn_a_s.CifsOpenFileDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsOpenFileDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsOpenFileDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsOpenFileDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsOpenFileGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsOpenFileGet(params *clientn_a_s.CifsOpenFileGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsOpenFileGet")
	}

	var r0 *clientn_a_s.CifsOpenFileGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsOpenFileGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsOpenFileGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsOpenFileGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsOpenFileGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsOpenFileGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSearchPathCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSearchPathCollectionGet(params *clientn_a_s.CifsSearchPathCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSearchPathCollectionGet")
	}

	var r0 *clientn_a_s.CifsSearchPathCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSearchPathCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSearchPathCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSearchPathCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSearchPathCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSearchPathCreate(params *clientn_a_s.CifsSearchPathCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSearchPathCreate")
	}

	var r0 *clientn_a_s.CifsSearchPathCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSearchPathCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSearchPathCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSearchPathCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSearchPathDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSearchPathDelete(params *clientn_a_s.CifsSearchPathDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSearchPathDelete")
	}

	var r0 *clientn_a_s.CifsSearchPathDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSearchPathDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSearchPathDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSearchPathDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSearchPathModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSearchPathModify(params *clientn_a_s.CifsSearchPathModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSearchPathModify")
	}

	var r0 *clientn_a_s.CifsSearchPathModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSearchPathModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSearchPathModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSearchPathModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSearchPathModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSearchPathModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsServiceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsServiceCollectionGet(params *clientn_a_s.CifsServiceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsServiceCollectionGet")
	}

	var r0 *clientn_a_s.CifsServiceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsServiceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsServiceCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsServiceCreate(params *clientn_a_s.CifsServiceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceCreateCreated, *clientn_a_s.CifsServiceCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsServiceCreate")
	}

	var r0 *clientn_a_s.CifsServiceCreateCreated
	var r1 *clientn_a_s.CifsServiceCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceCreateCreated, *clientn_a_s.CifsServiceCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsServiceCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.CifsServiceCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.CifsServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CifsServiceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsServiceDelete(params *clientn_a_s.CifsServiceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceDeleteOK, *clientn_a_s.CifsServiceDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsServiceDelete")
	}

	var r0 *clientn_a_s.CifsServiceDeleteOK
	var r1 *clientn_a_s.CifsServiceDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceDeleteOK, *clientn_a_s.CifsServiceDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsServiceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.CifsServiceDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.CifsServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CifsServiceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsServiceGet(params *clientn_a_s.CifsServiceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsServiceGet")
	}

	var r0 *clientn_a_s.CifsServiceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsServiceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsServiceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsServiceModify(params *clientn_a_s.CifsServiceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceModifyOK, *clientn_a_s.CifsServiceModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsServiceModify")
	}

	var r0 *clientn_a_s.CifsServiceModifyOK
	var r1 *clientn_a_s.CifsServiceModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsServiceModifyOK, *clientn_a_s.CifsServiceModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsServiceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsServiceModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.CifsServiceModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.CifsServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CifsSessionCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSessionCollectionGet(params *clientn_a_s.CifsSessionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSessionCollectionGet")
	}

	var r0 *clientn_a_s.CifsSessionCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSessionCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSessionCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSessionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSessionDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSessionDelete(params *clientn_a_s.CifsSessionDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSessionDelete")
	}

	var r0 *clientn_a_s.CifsSessionDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSessionDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSessionDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSessionDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSessionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSessionGet(params *clientn_a_s.CifsSessionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSessionGet")
	}

	var r0 *clientn_a_s.CifsSessionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSessionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSessionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSessionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSessionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSessionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareACLCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareACLCollectionGet(params *clientn_a_s.CifsShareACLCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareACLCollectionGet")
	}

	var r0 *clientn_a_s.CifsShareACLCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareACLCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareACLCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareACLCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareACLCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareACLCreate(params *clientn_a_s.CifsShareACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareACLCreate")
	}

	var r0 *clientn_a_s.CifsShareACLCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareACLCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareACLCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareACLDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareACLDelete(params *clientn_a_s.CifsShareACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareACLDelete")
	}

	var r0 *clientn_a_s.CifsShareACLDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareACLDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareACLDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareACLGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareACLGet(params *clientn_a_s.CifsShareACLGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareACLGet")
	}

	var r0 *clientn_a_s.CifsShareACLGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareACLGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareACLGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareACLGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareACLModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareACLModify(params *clientn_a_s.CifsShareACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareACLModify")
	}

	var r0 *clientn_a_s.CifsShareACLModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareACLModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareACLModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareACLModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareCollectionGet(params *clientn_a_s.CifsShareCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareCollectionGet")
	}

	var r0 *clientn_a_s.CifsShareCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareCreate(params *clientn_a_s.CifsShareCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareCreate")
	}

	var r0 *clientn_a_s.CifsShareCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareDelete(params *clientn_a_s.CifsShareDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareDelete")
	}

	var r0 *clientn_a_s.CifsShareDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareGet(params *clientn_a_s.CifsShareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareGet")
	}

	var r0 *clientn_a_s.CifsShareGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsShareModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsShareModify(params *clientn_a_s.CifsShareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsShareModify")
	}

	var r0 *clientn_a_s.CifsShareModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsShareModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsShareModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsShareModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsShareModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsShareModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSymlinkMappingCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSymlinkMappingCollectionGet(params *clientn_a_s.CifsSymlinkMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSymlinkMappingCollectionGet")
	}

	var r0 *clientn_a_s.CifsSymlinkMappingCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSymlinkMappingCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSymlinkMappingCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSymlinkMappingCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSymlinkMappingCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSymlinkMappingCreate(params *clientn_a_s.CifsSymlinkMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSymlinkMappingCreate")
	}

	var r0 *clientn_a_s.CifsSymlinkMappingCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSymlinkMappingCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSymlinkMappingCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSymlinkMappingCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSymlinkMappingDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSymlinkMappingDelete(params *clientn_a_s.CifsSymlinkMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSymlinkMappingDelete")
	}

	var r0 *clientn_a_s.CifsSymlinkMappingDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSymlinkMappingDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSymlinkMappingDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSymlinkMappingDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSymlinkMappingGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSymlinkMappingGet(params *clientn_a_s.CifsSymlinkMappingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSymlinkMappingGet")
	}

	var r0 *clientn_a_s.CifsSymlinkMappingGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSymlinkMappingGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSymlinkMappingGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSymlinkMappingGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CifsSymlinkMappingModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CifsSymlinkMappingModify(params *clientn_a_s.CifsSymlinkMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CifsSymlinkMappingModify")
	}

	var r0 *clientn_a_s.CifsSymlinkMappingModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.CifsSymlinkMappingModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.CifsSymlinkMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.CifsSymlinkMappingModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.CifsSymlinkMappingModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.CifsSymlinkMappingModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientLockCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClientLockCollectionGet(params *clientn_a_s.ClientLockCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientLockCollectionGet")
	}

	var r0 *clientn_a_s.ClientLockCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ClientLockCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ClientLockCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ClientLockCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientLockDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClientLockDelete(params *clientn_a_s.ClientLockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientLockDelete")
	}

	var r0 *clientn_a_s.ClientLockDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ClientLockDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ClientLockDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ClientLockDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientLockGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ClientLockGet(params *clientn_a_s.ClientLockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientLockGet")
	}

	var r0 *clientn_a_s.ClientLockGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ClientLockGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ClientLockGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ClientLockGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ClientLockGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ClientLockGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EffectivePermissionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) EffectivePermissionGet(params *clientn_a_s.EffectivePermissionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.EffectivePermissionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EffectivePermissionGet")
	}

	var r0 *clientn_a_s.EffectivePermissionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.EffectivePermissionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.EffectivePermissionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.EffectivePermissionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.EffectivePermissionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.EffectivePermissionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.EffectivePermissionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportPolicyCollectionGet(params *clientn_a_s.ExportPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportPolicyCollectionGet")
	}

	var r0 *clientn_a_s.ExportPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportPolicyCreate(params *clientn_a_s.ExportPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportPolicyCreate")
	}

	var r0 *clientn_a_s.ExportPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportPolicyDelete(params *clientn_a_s.ExportPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportPolicyDelete")
	}

	var r0 *clientn_a_s.ExportPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportPolicyGet(params *clientn_a_s.ExportPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportPolicyGet")
	}

	var r0 *clientn_a_s.ExportPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportPolicyModify(params *clientn_a_s.ExportPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportPolicyModify")
	}

	var r0 *clientn_a_s.ExportPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleClientsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleClientsCreate(params *clientn_a_s.ExportRuleClientsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleClientsCreate")
	}

	var r0 *clientn_a_s.ExportRuleClientsCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleClientsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleClientsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleClientsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleClientsDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleClientsDelete(params *clientn_a_s.ExportRuleClientsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleClientsDelete")
	}

	var r0 *clientn_a_s.ExportRuleClientsDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleClientsDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleClientsDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleClientsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleClientsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleClientsGet(params *clientn_a_s.ExportRuleClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleClientsGet")
	}

	var r0 *clientn_a_s.ExportRuleClientsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleClientsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleClientsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleClientsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleCollectionGet(params *clientn_a_s.ExportRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleCollectionGet")
	}

	var r0 *clientn_a_s.ExportRuleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleCreate(params *clientn_a_s.ExportRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleCreate")
	}

	var r0 *clientn_a_s.ExportRuleCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleDelete(params *clientn_a_s.ExportRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleDelete")
	}

	var r0 *clientn_a_s.ExportRuleDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleGet(params *clientn_a_s.ExportRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleGet")
	}

	var r0 *clientn_a_s.ExportRuleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRuleModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ExportRuleModify(params *clientn_a_s.ExportRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRuleModify")
	}

	var r0 *clientn_a_s.ExportRuleModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ExportRuleModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ExportRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ExportRuleModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ExportRuleModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ExportRuleModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileDirectorySecurityACLCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityACLCreate(params *clientn_a_s.FileDirectorySecurityACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLCreateCreated, *clientn_a_s.FileDirectorySecurityACLCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityACLCreate")
	}

	var r0 *clientn_a_s.FileDirectorySecurityACLCreateCreated
	var r1 *clientn_a_s.FileDirectorySecurityACLCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLCreateCreated, *clientn_a_s.FileDirectorySecurityACLCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityACLCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.FileDirectorySecurityACLCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.FileDirectorySecurityACLCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileDirectorySecurityACLDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityACLDelete(params *clientn_a_s.FileDirectorySecurityACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLDeleteOK, *clientn_a_s.FileDirectorySecurityACLDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityACLDelete")
	}

	var r0 *clientn_a_s.FileDirectorySecurityACLDeleteOK
	var r1 *clientn_a_s.FileDirectorySecurityACLDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLDeleteOK, *clientn_a_s.FileDirectorySecurityACLDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityACLDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.FileDirectorySecurityACLDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.FileDirectorySecurityACLDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileDirectorySecurityACLModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityACLModify(params *clientn_a_s.FileDirectorySecurityACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLModifyOK, *clientn_a_s.FileDirectorySecurityACLModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityACLModify")
	}

	var r0 *clientn_a_s.FileDirectorySecurityACLModifyOK
	var r1 *clientn_a_s.FileDirectorySecurityACLModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityACLModifyOK, *clientn_a_s.FileDirectorySecurityACLModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityACLModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityACLModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.FileDirectorySecurityACLModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.FileDirectorySecurityACLModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileDirectorySecurityCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityCreate(params *clientn_a_s.FileDirectorySecurityCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityCreateCreated, *clientn_a_s.FileDirectorySecurityCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityCreate")
	}

	var r0 *clientn_a_s.FileDirectorySecurityCreateCreated
	var r1 *clientn_a_s.FileDirectorySecurityCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityCreateCreated, *clientn_a_s.FileDirectorySecurityCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.FileDirectorySecurityCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.FileDirectorySecurityCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileDirectorySecurityDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityDelete(params *clientn_a_s.FileDirectorySecurityDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityDelete")
	}

	var r0 *clientn_a_s.FileDirectorySecurityDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileDirectorySecurityGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityGet(params *clientn_a_s.FileDirectorySecurityGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityGet")
	}

	var r0 *clientn_a_s.FileDirectorySecurityGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileDirectorySecurityModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FileDirectorySecurityModify(params *clientn_a_s.FileDirectorySecurityModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityModifyOK, *clientn_a_s.FileDirectorySecurityModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FileDirectorySecurityModify")
	}

	var r0 *clientn_a_s.FileDirectorySecurityModifyOK
	var r1 *clientn_a_s.FileDirectorySecurityModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FileDirectorySecurityModifyOK, *clientn_a_s.FileDirectorySecurityModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FileDirectorySecurityModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FileDirectorySecurityModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FileDirectorySecurityModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FileDirectorySecurityModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.FileDirectorySecurityModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.FileDirectorySecurityModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FpolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyCollectionGet(params *clientn_a_s.FpolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyConnectionCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyConnectionCollectionGet(params *clientn_a_s.FpolicyConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyConnectionCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyConnectionCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyConnectionCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyConnectionCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyConnectionCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyConnectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyConnectionGet(params *clientn_a_s.FpolicyConnectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyConnectionGet")
	}

	var r0 *clientn_a_s.FpolicyConnectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyConnectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyConnectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyConnectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyConnectionModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyConnectionModify(params *clientn_a_s.FpolicyConnectionModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyConnectionModify")
	}

	var r0 *clientn_a_s.FpolicyConnectionModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyConnectionModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyConnectionModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyConnectionModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyConnectionModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyConnectionModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyCreate(params *clientn_a_s.FpolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyCreate")
	}

	var r0 *clientn_a_s.FpolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyDelete(params *clientn_a_s.FpolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyDelete")
	}

	var r0 *clientn_a_s.FpolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEngineCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEngineCollectionGet(params *clientn_a_s.FpolicyEngineCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEngineCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyEngineCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEngineCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEngineCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEngineCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEngineCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEngineCreate(params *clientn_a_s.FpolicyEngineCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEngineCreate")
	}

	var r0 *clientn_a_s.FpolicyEngineCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEngineCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEngineCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEngineCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEngineDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEngineDelete(params *clientn_a_s.FpolicyEngineDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEngineDelete")
	}

	var r0 *clientn_a_s.FpolicyEngineDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEngineDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEngineDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEngineDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEngineGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEngineGet(params *clientn_a_s.FpolicyEngineGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEngineGet")
	}

	var r0 *clientn_a_s.FpolicyEngineGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEngineGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEngineGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEngineGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEngineModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEngineModify(params *clientn_a_s.FpolicyEngineModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEngineModify")
	}

	var r0 *clientn_a_s.FpolicyEngineModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEngineModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEngineModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEngineModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEngineModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEngineModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEventCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEventCollectionGet(params *clientn_a_s.FpolicyEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEventCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyEventCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEventCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEventCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEventCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEventCreate(params *clientn_a_s.FpolicyEventCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEventCreate")
	}

	var r0 *clientn_a_s.FpolicyEventCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEventCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEventCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEventCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEventDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEventDelete(params *clientn_a_s.FpolicyEventDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEventDelete")
	}

	var r0 *clientn_a_s.FpolicyEventDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEventDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEventDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEventDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEventModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEventModify(params *clientn_a_s.FpolicyEventModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEventModify")
	}

	var r0 *clientn_a_s.FpolicyEventModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEventModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEventModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEventModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyEventsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyEventsGet(params *clientn_a_s.FpolicyEventsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyEventsGet")
	}

	var r0 *clientn_a_s.FpolicyEventsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyEventsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyEventsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyEventsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyEventsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyEventsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyGet(params *clientn_a_s.FpolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyGet")
	}

	var r0 *clientn_a_s.FpolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPersistentStoreCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPersistentStoreCollectionGet(params *clientn_a_s.FpolicyPersistentStoreCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPersistentStoreCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyPersistentStoreCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPersistentStoreCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPersistentStoreCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPersistentStoreCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPersistentStoreCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPersistentStoreCreate(params *clientn_a_s.FpolicyPersistentStoreCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPersistentStoreCreate")
	}

	var r0 *clientn_a_s.FpolicyPersistentStoreCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPersistentStoreCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPersistentStoreCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPersistentStoreCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPersistentStoreDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPersistentStoreDelete(params *clientn_a_s.FpolicyPersistentStoreDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPersistentStoreDelete")
	}

	var r0 *clientn_a_s.FpolicyPersistentStoreDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPersistentStoreDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPersistentStoreDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPersistentStoreDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPersistentStoreGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPersistentStoreGet(params *clientn_a_s.FpolicyPersistentStoreGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPersistentStoreGet")
	}

	var r0 *clientn_a_s.FpolicyPersistentStoreGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPersistentStoreGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPersistentStoreGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPersistentStoreGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPersistentStoreModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPersistentStoreModify(params *clientn_a_s.FpolicyPersistentStoreModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPersistentStoreModify")
	}

	var r0 *clientn_a_s.FpolicyPersistentStoreModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPersistentStoreModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPersistentStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPersistentStoreModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPersistentStoreModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPersistentStoreModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPolicyCollectionGet(params *clientn_a_s.FpolicyPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPolicyCollectionGet")
	}

	var r0 *clientn_a_s.FpolicyPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPolicyCreate(params *clientn_a_s.FpolicyPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPolicyCreate")
	}

	var r0 *clientn_a_s.FpolicyPolicyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPolicyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPolicyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPolicyDelete(params *clientn_a_s.FpolicyPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPolicyDelete")
	}

	var r0 *clientn_a_s.FpolicyPolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPolicyGet(params *clientn_a_s.FpolicyPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPolicyGet")
	}

	var r0 *clientn_a_s.FpolicyPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FpolicyPolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FpolicyPolicyModify(params *clientn_a_s.FpolicyPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FpolicyPolicyModify")
	}

	var r0 *clientn_a_s.FpolicyPolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.FpolicyPolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.FpolicyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.FpolicyPolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.FpolicyPolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.FpolicyPolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPoliciesToBeAppliedModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPoliciesToBeAppliedModify(params *clientn_a_s.GroupPoliciesToBeAppliedModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPoliciesToBeAppliedModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPoliciesToBeAppliedModify")
	}

	var r0 *clientn_a_s.GroupPoliciesToBeAppliedModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPoliciesToBeAppliedModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPoliciesToBeAppliedModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPoliciesToBeAppliedModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPoliciesToBeAppliedModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPoliciesToBeAppliedModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPoliciesToBeAppliedModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectCentralAccessPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectCentralAccessPolicyCollectionGet(params *clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectCentralAccessPolicyCollectionGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectCentralAccessPolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectCentralAccessPolicyGet(params *clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectCentralAccessPolicyGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectCentralAccessPolicyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectCentralAccessRuleCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectCentralAccessRuleCollectionGet(params *clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectCentralAccessRuleCollectionGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectCentralAccessRuleGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectCentralAccessRuleGet(params *clientn_a_s.GroupPolicyObjectCentralAccessRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectCentralAccessRuleGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectCentralAccessRuleGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectCentralAccessRuleGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectCentralAccessRuleGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectCollectionGet(params *clientn_a_s.GroupPolicyObjectCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectCollectionGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectGet(params *clientn_a_s.GroupPolicyObjectGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectRestrictedGroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectRestrictedGroupCollectionGet(params *clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectRestrictedGroupCollectionGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupPolicyObjectRestrictedGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GroupPolicyObjectRestrictedGroupGet(params *clientn_a_s.GroupPolicyObjectRestrictedGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectRestrictedGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupPolicyObjectRestrictedGroupGet")
	}

	var r0 *clientn_a_s.GroupPolicyObjectRestrictedGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.GroupPolicyObjectRestrictedGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.GroupPolicyObjectRestrictedGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.GroupPolicyObjectRestrictedGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.GroupPolicyObjectRestrictedGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosInterfaceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosInterfaceCollectionGet(params *clientn_a_s.KerberosInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosInterfaceCollectionGet")
	}

	var r0 *clientn_a_s.KerberosInterfaceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosInterfaceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosInterfaceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosInterfaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosInterfaceGet(params *clientn_a_s.KerberosInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosInterfaceGet")
	}

	var r0 *clientn_a_s.KerberosInterfaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosInterfaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosInterfaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosInterfaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosInterfaceModify(params *clientn_a_s.KerberosInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosInterfaceModify")
	}

	var r0 *clientn_a_s.KerberosInterfaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosInterfaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosInterfaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosInterfaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosRealmCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosRealmCollectionGet(params *clientn_a_s.KerberosRealmCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosRealmCollectionGet")
	}

	var r0 *clientn_a_s.KerberosRealmCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosRealmCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosRealmCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosRealmCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosRealmCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosRealmCreate(params *clientn_a_s.KerberosRealmCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosRealmCreate")
	}

	var r0 *clientn_a_s.KerberosRealmCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosRealmCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosRealmCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosRealmCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosRealmDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosRealmDelete(params *clientn_a_s.KerberosRealmDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosRealmDelete")
	}

	var r0 *clientn_a_s.KerberosRealmDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosRealmDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosRealmDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosRealmDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosRealmGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosRealmGet(params *clientn_a_s.KerberosRealmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosRealmGet")
	}

	var r0 *clientn_a_s.KerberosRealmGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosRealmGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosRealmGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosRealmGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KerberosRealmModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) KerberosRealmModify(params *clientn_a_s.KerberosRealmModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for KerberosRealmModify")
	}

	var r0 *clientn_a_s.KerberosRealmModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.KerberosRealmModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.KerberosRealmModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.KerberosRealmModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.KerberosRealmModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.KerberosRealmModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupCollectionGet(params *clientn_a_s.LocalCifsGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupCollectionGet")
	}

	var r0 *clientn_a_s.LocalCifsGroupCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupCreate(params *clientn_a_s.LocalCifsGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupCreate")
	}

	var r0 *clientn_a_s.LocalCifsGroupCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupDelete(params *clientn_a_s.LocalCifsGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupDelete")
	}

	var r0 *clientn_a_s.LocalCifsGroupDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupGet(params *clientn_a_s.LocalCifsGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupGet")
	}

	var r0 *clientn_a_s.LocalCifsGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupMembersBulkDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupMembersBulkDelete(params *clientn_a_s.LocalCifsGroupMembersBulkDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersBulkDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupMembersBulkDelete")
	}

	var r0 *clientn_a_s.LocalCifsGroupMembersBulkDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersBulkDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersBulkDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersBulkDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupMembersBulkDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupMembersBulkDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupMembersBulkDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupMembersCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupMembersCollectionGet(params *clientn_a_s.LocalCifsGroupMembersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupMembersCollectionGet")
	}

	var r0 *clientn_a_s.LocalCifsGroupMembersCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupMembersCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupMembersCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupMembersCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupMembersCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupMembersCreate(params *clientn_a_s.LocalCifsGroupMembersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupMembersCreate")
	}

	var r0 *clientn_a_s.LocalCifsGroupMembersCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupMembersCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupMembersCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupMembersCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupMembersDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupMembersDelete(params *clientn_a_s.LocalCifsGroupMembersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupMembersDelete")
	}

	var r0 *clientn_a_s.LocalCifsGroupMembersDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupMembersDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupMembersDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupMembersDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupMembersGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupMembersGet(params *clientn_a_s.LocalCifsGroupMembersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupMembersGet")
	}

	var r0 *clientn_a_s.LocalCifsGroupMembersGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupMembersGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupMembersGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupMembersGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupMembersGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupMembersGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsGroupModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsGroupModify(params *clientn_a_s.LocalCifsGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsGroupModify")
	}

	var r0 *clientn_a_s.LocalCifsGroupModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsGroupModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsGroupModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsGroupModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUserCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUserCollectionGet(params *clientn_a_s.LocalCifsUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUserCollectionGet")
	}

	var r0 *clientn_a_s.LocalCifsUserCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUserCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUserCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUserCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUserCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUserCreate(params *clientn_a_s.LocalCifsUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUserCreate")
	}

	var r0 *clientn_a_s.LocalCifsUserCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUserCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUserCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUserCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUserDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUserDelete(params *clientn_a_s.LocalCifsUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUserDelete")
	}

	var r0 *clientn_a_s.LocalCifsUserDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUserDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUserDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUserDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUserGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUserGet(params *clientn_a_s.LocalCifsUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUserGet")
	}

	var r0 *clientn_a_s.LocalCifsUserGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUserGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUserGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUserGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUserModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUserModify(params *clientn_a_s.LocalCifsUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUserModify")
	}

	var r0 *clientn_a_s.LocalCifsUserModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUserModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUserModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUserModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUserModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUserModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUsersAndGroupsImportCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUsersAndGroupsImportCreate(params *clientn_a_s.LocalCifsUsersAndGroupsImportCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportCreateCreated, *clientn_a_s.LocalCifsUsersAndGroupsImportCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUsersAndGroupsImportCreate")
	}

	var r0 *clientn_a_s.LocalCifsUsersAndGroupsImportCreateCreated
	var r1 *clientn_a_s.LocalCifsUsersAndGroupsImportCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportCreateCreated, *clientn_a_s.LocalCifsUsersAndGroupsImportCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUsersAndGroupsImportCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUsersAndGroupsImportCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LocalCifsUsersAndGroupsImportGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUsersAndGroupsImportGet(params *clientn_a_s.LocalCifsUsersAndGroupsImportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUsersAndGroupsImportGet")
	}

	var r0 *clientn_a_s.LocalCifsUsersAndGroupsImportGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUsersAndGroupsImportGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUsersAndGroupsImportGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalCifsUsersAndGroupsImportModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) LocalCifsUsersAndGroupsImportModify(params *clientn_a_s.LocalCifsUsersAndGroupsImportModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportModifyOK, *clientn_a_s.LocalCifsUsersAndGroupsImportModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LocalCifsUsersAndGroupsImportModify")
	}

	var r0 *clientn_a_s.LocalCifsUsersAndGroupsImportModifyOK
	var r1 *clientn_a_s.LocalCifsUsersAndGroupsImportModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.LocalCifsUsersAndGroupsImportModifyOK, *clientn_a_s.LocalCifsUsersAndGroupsImportModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUsersAndGroupsImportModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.LocalCifsUsersAndGroupsImportModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.LocalCifsUsersAndGroupsImportModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NetbiosCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetbiosCollectionGet(params *clientn_a_s.NetbiosCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NetbiosCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetbiosCollectionGet")
	}

	var r0 *clientn_a_s.NetbiosCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NetbiosCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NetbiosCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NetbiosCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NetbiosCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NetbiosCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NetbiosCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsClientsCacheGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsClientsCacheGet(params *clientn_a_s.NfsClientsCacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsCacheGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsClientsCacheGet")
	}

	var r0 *clientn_a_s.NfsClientsCacheGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsCacheGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsCacheGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsCacheGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsClientsCacheGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsClientsCacheGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsClientsCacheGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsClientsCacheModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsClientsCacheModify(params *clientn_a_s.NfsClientsCacheModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsCacheModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsClientsCacheModify")
	}

	var r0 *clientn_a_s.NfsClientsCacheModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsCacheModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsCacheModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsCacheModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsClientsCacheModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsClientsCacheModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsClientsCacheModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsClientsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsClientsGet(params *clientn_a_s.NfsClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsClientsGet")
	}

	var r0 *clientn_a_s.NfsClientsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsClientsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsClientsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsClientsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsClientsMapGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsClientsMapGet(params *clientn_a_s.NfsClientsMapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsMapGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsClientsMapGet")
	}

	var r0 *clientn_a_s.NfsClientsMapGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsClientsMapGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsClientsMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsClientsMapGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsClientsMapGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsClientsMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsCollectionGet(params *clientn_a_s.NfsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsCollectionGet")
	}

	var r0 *clientn_a_s.NfsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsCollectionPerformanceMetricsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsCollectionPerformanceMetricsGet(params *clientn_a_s.NfsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCollectionPerformanceMetricsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsCollectionPerformanceMetricsGet")
	}

	var r0 *clientn_a_s.NfsCollectionPerformanceMetricsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCollectionPerformanceMetricsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsCollectionPerformanceMetricsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsCollectionPerformanceMetricsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsCollectionPerformanceMetricsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsCreate(params *clientn_a_s.NfsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsCreate")
	}

	var r0 *clientn_a_s.NfsCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsDelete(params *clientn_a_s.NfsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsDelete")
	}

	var r0 *clientn_a_s.NfsDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsGet(params *clientn_a_s.NfsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsGet")
	}

	var r0 *clientn_a_s.NfsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsModify(params *clientn_a_s.NfsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsModify")
	}

	var r0 *clientn_a_s.NfsModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsTLSInterfaceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsTLSInterfaceCollectionGet(params *clientn_a_s.NfsTLSInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsTLSInterfaceCollectionGet")
	}

	var r0 *clientn_a_s.NfsTLSInterfaceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsTLSInterfaceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsTLSInterfaceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsTLSInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsTLSInterfaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsTLSInterfaceGet(params *clientn_a_s.NfsTLSInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsTLSInterfaceGet")
	}

	var r0 *clientn_a_s.NfsTLSInterfaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsTLSInterfaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsTLSInterfaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsTLSInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NfsTLSInterfaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NfsTLSInterfaceModify(params *clientn_a_s.NfsTLSInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NfsTLSInterfaceModify")
	}

	var r0 *clientn_a_s.NfsTLSInterfaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.NfsTLSInterfaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.NfsTLSInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.NfsTLSInterfaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.NfsTLSInterfaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.NfsTLSInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PoliciesAndRulesToBeAppliedCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PoliciesAndRulesToBeAppliedCollectionGet(params *clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PoliciesAndRulesToBeAppliedCollectionGet")
	}

	var r0 *clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PoliciesAndRulesToBeAppliedGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PoliciesAndRulesToBeAppliedGet(params *clientn_a_s.PoliciesAndRulesToBeAppliedGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.PoliciesAndRulesToBeAppliedGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PoliciesAndRulesToBeAppliedGet")
	}

	var r0 *clientn_a_s.PoliciesAndRulesToBeAppliedGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.PoliciesAndRulesToBeAppliedGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.PoliciesAndRulesToBeAppliedGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.PoliciesAndRulesToBeAppliedGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.PoliciesAndRulesToBeAppliedGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// S3AuditCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) S3AuditCreate(params *clientn_a_s.S3AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditCreateCreated, *clientn_a_s.S3AuditCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for S3AuditCreate")
	}

	var r0 *clientn_a_s.S3AuditCreateCreated
	var r1 *clientn_a_s.S3AuditCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditCreateCreated, *clientn_a_s.S3AuditCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.S3AuditCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.S3AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.S3AuditCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.S3AuditCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// S3AuditDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) S3AuditDelete(params *clientn_a_s.S3AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditDeleteOK, *clientn_a_s.S3AuditDeleteAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for S3AuditDelete")
	}

	var r0 *clientn_a_s.S3AuditDeleteOK
	var r1 *clientn_a_s.S3AuditDeleteAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditDeleteOK, *clientn_a_s.S3AuditDeleteAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.S3AuditDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.S3AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditDeleteAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.S3AuditDeleteAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.S3AuditDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// S3AuditGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) S3AuditGet(params *clientn_a_s.S3AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for S3AuditGet")
	}

	var r0 *clientn_a_s.S3AuditGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.S3AuditGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.S3AuditGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// S3AuditModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) S3AuditModify(params *clientn_a_s.S3AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditModifyOK, *clientn_a_s.S3AuditModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for S3AuditModify")
	}

	var r0 *clientn_a_s.S3AuditModifyOK
	var r1 *clientn_a_s.S3AuditModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.S3AuditModifyOK, *clientn_a_s.S3AuditModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.S3AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.S3AuditModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.S3AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.S3AuditModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientn_a_s.S3AuditModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientn_a_s.S3AuditModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// ShadowcopyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopyCollectionGet(params *clientn_a_s.ShadowcopyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopyCollectionGet")
	}

	var r0 *clientn_a_s.ShadowcopyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShadowcopyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopyGet(params *clientn_a_s.ShadowcopyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopyGet")
	}

	var r0 *clientn_a_s.ShadowcopyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopyGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShadowcopyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopyModify(params *clientn_a_s.ShadowcopyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopyModify")
	}

	var r0 *clientn_a_s.ShadowcopyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopyModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShadowcopySetCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopySetCollectionGet(params *clientn_a_s.ShadowcopySetCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopySetCollectionGet")
	}

	var r0 *clientn_a_s.ShadowcopySetCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopySetCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopySetCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopySetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShadowcopySetGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopySetGet(params *clientn_a_s.ShadowcopySetGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopySetGet")
	}

	var r0 *clientn_a_s.ShadowcopySetGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopySetGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopySetGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopySetGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShadowcopySetModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ShadowcopySetModify(params *clientn_a_s.ShadowcopySetModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShadowcopySetModify")
	}

	var r0 *clientn_a_s.ShadowcopySetModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.ShadowcopySetModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.ShadowcopySetModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.ShadowcopySetModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.ShadowcopySetModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.ShadowcopySetModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGroupPrivilegesCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UserGroupPrivilegesCollectionGet(params *clientn_a_s.UserGroupPrivilegesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupPrivilegesCollectionGet")
	}

	var r0 *clientn_a_s.UserGroupPrivilegesCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.UserGroupPrivilegesCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.UserGroupPrivilegesCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.UserGroupPrivilegesCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGroupPrivilegesCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UserGroupPrivilegesCreate(params *clientn_a_s.UserGroupPrivilegesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupPrivilegesCreate")
	}

	var r0 *clientn_a_s.UserGroupPrivilegesCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.UserGroupPrivilegesCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.UserGroupPrivilegesCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.UserGroupPrivilegesCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGroupPrivilegesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UserGroupPrivilegesGet(params *clientn_a_s.UserGroupPrivilegesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupPrivilegesGet")
	}

	var r0 *clientn_a_s.UserGroupPrivilegesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.UserGroupPrivilegesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.UserGroupPrivilegesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.UserGroupPrivilegesGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGroupPrivilegesModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UserGroupPrivilegesModify(params *clientn_a_s.UserGroupPrivilegesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupPrivilegesModify")
	}

	var r0 *clientn_a_s.UserGroupPrivilegesModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.UserGroupPrivilegesModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.UserGroupPrivilegesModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.UserGroupPrivilegesModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.UserGroupPrivilegesModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.UserGroupPrivilegesModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanCollectionGet(params *clientn_a_s.VscanCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanCollectionGet")
	}

	var r0 *clientn_a_s.VscanCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanConfigDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanConfigDelete(params *clientn_a_s.VscanConfigDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanConfigDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanConfigDelete")
	}

	var r0 *clientn_a_s.VscanConfigDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanConfigDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanConfigDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanConfigDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanConfigDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanConfigDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanConfigDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanCreate(params *clientn_a_s.VscanCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanCreate")
	}

	var r0 *clientn_a_s.VscanCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanEventCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanEventCollectionGet(params *clientn_a_s.VscanEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanEventCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanEventCollectionGet")
	}

	var r0 *clientn_a_s.VscanEventCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanEventCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanEventCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanEventCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanEventCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanGet(params *clientn_a_s.VscanGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanGet")
	}

	var r0 *clientn_a_s.VscanGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanModify(params *clientn_a_s.VscanModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanModify")
	}

	var r0 *clientn_a_s.VscanModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnAccessCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnAccessCreate(params *clientn_a_s.VscanOnAccessCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnAccessCreate")
	}

	var r0 *clientn_a_s.VscanOnAccessCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnAccessCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnAccessCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnAccessCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnAccessDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnAccessDelete(params *clientn_a_s.VscanOnAccessDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnAccessDelete")
	}

	var r0 *clientn_a_s.VscanOnAccessDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnAccessDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnAccessDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnAccessDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnAccessGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnAccessGet(params *clientn_a_s.VscanOnAccessGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnAccessGet")
	}

	var r0 *clientn_a_s.VscanOnAccessGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnAccessGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnAccessGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnAccessGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnAccessModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnAccessModify(params *clientn_a_s.VscanOnAccessModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnAccessModify")
	}

	var r0 *clientn_a_s.VscanOnAccessModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnAccessModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnAccessModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnAccessModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnAccessPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnAccessPolicyCollectionGet(params *clientn_a_s.VscanOnAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnAccessPolicyCollectionGet")
	}

	var r0 *clientn_a_s.VscanOnAccessPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnAccessPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnAccessPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnAccessPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnAccessPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnDemandCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnDemandCreate(params *clientn_a_s.VscanOnDemandCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnDemandCreate")
	}

	var r0 *clientn_a_s.VscanOnDemandCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnDemandCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnDemandCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnDemandCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnDemandDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnDemandDelete(params *clientn_a_s.VscanOnDemandDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnDemandDelete")
	}

	var r0 *clientn_a_s.VscanOnDemandDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnDemandDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnDemandDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnDemandDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnDemandGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnDemandGet(params *clientn_a_s.VscanOnDemandGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnDemandGet")
	}

	var r0 *clientn_a_s.VscanOnDemandGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnDemandGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnDemandGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnDemandGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnDemandModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnDemandModify(params *clientn_a_s.VscanOnDemandModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnDemandModify")
	}

	var r0 *clientn_a_s.VscanOnDemandModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnDemandModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnDemandModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnDemandModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanOnDemandPolicyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanOnDemandPolicyCollectionGet(params *clientn_a_s.VscanOnDemandPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandPolicyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanOnDemandPolicyCollectionGet")
	}

	var r0 *clientn_a_s.VscanOnDemandPolicyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanOnDemandPolicyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanOnDemandPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanOnDemandPolicyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanOnDemandPolicyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanOnDemandPolicyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanScannerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanScannerCollectionGet(params *clientn_a_s.VscanScannerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanScannerCollectionGet")
	}

	var r0 *clientn_a_s.VscanScannerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanScannerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanScannerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanScannerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanScannerCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanScannerCreate(params *clientn_a_s.VscanScannerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanScannerCreate")
	}

	var r0 *clientn_a_s.VscanScannerCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanScannerCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanScannerCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanScannerCreateParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanScannerDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanScannerDelete(params *clientn_a_s.VscanScannerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanScannerDelete")
	}

	var r0 *clientn_a_s.VscanScannerDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanScannerDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanScannerDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanScannerDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanScannerModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanScannerModify(params *clientn_a_s.VscanScannerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanScannerModify")
	}

	var r0 *clientn_a_s.VscanScannerModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanScannerModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanScannerModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanScannerModifyParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanScannerPoolGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanScannerPoolGet(params *clientn_a_s.VscanScannerPoolGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerPoolGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanScannerPoolGet")
	}

	var r0 *clientn_a_s.VscanScannerPoolGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerPoolGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanScannerPoolGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanScannerPoolGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanScannerPoolGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanScannerPoolGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanScannerPoolGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VscanServerStatusGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) VscanServerStatusGet(params *clientn_a_s.VscanServerStatusGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_a_s.ClientOption) (*clientn_a_s.VscanServerStatusGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VscanServerStatusGet")
	}

	var r0 *clientn_a_s.VscanServerStatusGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanServerStatusGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) (*clientn_a_s.VscanServerStatusGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_a_s.VscanServerStatusGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) *clientn_a_s.VscanServerStatusGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_a_s.VscanServerStatusGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_a_s.VscanServerStatusGetParams, runtime.ClientAuthInfoWriter, ...clientn_a_s.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
