// Code generated by mockery v2.51.0. DO NOT EDIT.

package networking

import (
	clientnetworking "github.com/metal-stack/ontap-go/api/client/networking"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// FabricCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FabricCollectionGet(params *clientnetworking.FabricCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FabricCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FabricCollectionGet")
	}

	var r0 *clientnetworking.FabricCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FabricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FabricCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FabricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FabricCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FabricCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FabricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FabricGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FabricGet(params *clientnetworking.FabricGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FabricGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FabricGet")
	}

	var r0 *clientnetworking.FabricGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FabricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FabricGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FabricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FabricGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FabricGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FabricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcInterfaceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcInterfaceCollectionGet(params *clientnetworking.FcInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcInterfaceCollectionGet")
	}

	var r0 *clientnetworking.FcInterfaceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcInterfaceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcInterfaceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcInterfaceCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcInterfaceCreate(params *clientnetworking.FcInterfaceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcInterfaceCreate")
	}

	var r0 *clientnetworking.FcInterfaceCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcInterfaceCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcInterfaceCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcInterfaceCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcInterfaceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcInterfaceDelete(params *clientnetworking.FcInterfaceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcInterfaceDelete")
	}

	var r0 *clientnetworking.FcInterfaceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcInterfaceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcInterfaceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcInterfaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcInterfaceGet(params *clientnetworking.FcInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcInterfaceGet")
	}

	var r0 *clientnetworking.FcInterfaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcInterfaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcInterfaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcInterfaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcInterfaceModify(params *clientnetworking.FcInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcInterfaceModify")
	}

	var r0 *clientnetworking.FcInterfaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcInterfaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcInterfaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcInterfaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcPortCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcPortCollectionGet(params *clientnetworking.FcPortCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcPortCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcPortCollectionGet")
	}

	var r0 *clientnetworking.FcPortCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcPortCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcPortCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcPortCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcPortGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcPortGet(params *clientnetworking.FcPortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcPortGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcPortGet")
	}

	var r0 *clientnetworking.FcPortGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcPortGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcPortGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcPortGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcPortModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcPortModify(params *clientnetworking.FcPortModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcPortModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcPortModify")
	}

	var r0 *clientnetworking.FcPortModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcPortModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcPortModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcPortModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcSwitchCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcSwitchCollectionGet(params *clientnetworking.FcSwitchCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcSwitchCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcSwitchCollectionGet")
	}

	var r0 *clientnetworking.FcSwitchCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcSwitchCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcSwitchCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcSwitchCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcSwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcSwitchGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcSwitchGet(params *clientnetworking.FcSwitchGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcSwitchGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcSwitchGet")
	}

	var r0 *clientnetworking.FcSwitchGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcSwitchGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcSwitchGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcSwitchGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcSwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcZoneCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcZoneCollectionGet(params *clientnetworking.FcZoneCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcZoneCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcZoneCollectionGet")
	}

	var r0 *clientnetworking.FcZoneCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcZoneCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcZoneCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcZoneCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcZoneCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcZoneCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcZoneCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FcZoneGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FcZoneGet(params *clientnetworking.FcZoneGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.FcZoneGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FcZoneGet")
	}

	var r0 *clientnetworking.FcZoneGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcZoneGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.FcZoneGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.FcZoneGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.FcZoneGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.FcZoneGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.FcZoneGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HTTPProxyCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HTTPProxyCollectionGet(params *clientnetworking.HTTPProxyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTPProxyCollectionGet")
	}

	var r0 *clientnetworking.HTTPProxyCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.HTTPProxyCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.HTTPProxyCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.HTTPProxyCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HTTPProxyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HTTPProxyCreate(params *clientnetworking.HTTPProxyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTPProxyCreate")
	}

	var r0 *clientnetworking.HTTPProxyCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.HTTPProxyCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.HTTPProxyCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.HTTPProxyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HTTPProxyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HTTPProxyDelete(params *clientnetworking.HTTPProxyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTPProxyDelete")
	}

	var r0 *clientnetworking.HTTPProxyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.HTTPProxyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.HTTPProxyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.HTTPProxyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HTTPProxyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HTTPProxyGet(params *clientnetworking.HTTPProxyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTPProxyGet")
	}

	var r0 *clientnetworking.HTTPProxyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.HTTPProxyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.HTTPProxyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.HTTPProxyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HTTPProxyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) HTTPProxyModify(params *clientnetworking.HTTPProxyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTPProxyModify")
	}

	var r0 *clientnetworking.HTTPProxyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.HTTPProxyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.HTTPProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.HTTPProxyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.HTTPProxyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.HTTPProxyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPServicePolicyCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPServicePolicyCreate(params *clientnetworking.IPServicePolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyCreateOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPServicePolicyCreate")
	}

	var r0 *clientnetworking.IPServicePolicyCreateOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyCreateOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPServicePolicyCreateOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPServicePolicyCreateOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPServicePolicyCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPServicePolicyDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPServicePolicyDelete(params *clientnetworking.IPServicePolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPServicePolicyDelete")
	}

	var r0 *clientnetworking.IPServicePolicyDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPServicePolicyDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPServicePolicyDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPServicePolicyDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPServicePolicyModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPServicePolicyModify(params *clientnetworking.IPServicePolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPServicePolicyModify")
	}

	var r0 *clientnetworking.IPServicePolicyModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPServicePolicyModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPServicePolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPServicePolicyModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPServicePolicyModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPServicePolicyModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPSubnetCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPSubnetCollectionGet(params *clientnetworking.IPSubnetCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPSubnetCollectionGet")
	}

	var r0 *clientnetworking.IPSubnetCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPSubnetCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPSubnetCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPSubnetCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPSubnetCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPSubnetCreate(params *clientnetworking.IPSubnetCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPSubnetCreate")
	}

	var r0 *clientnetworking.IPSubnetCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPSubnetCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPSubnetCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPSubnetCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPSubnetDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPSubnetDelete(params *clientnetworking.IPSubnetDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPSubnetDelete")
	}

	var r0 *clientnetworking.IPSubnetDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPSubnetDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPSubnetDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPSubnetDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPSubnetGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPSubnetGet(params *clientnetworking.IPSubnetGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPSubnetGet")
	}

	var r0 *clientnetworking.IPSubnetGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPSubnetGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPSubnetGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPSubnetGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPSubnetModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IPSubnetModify(params *clientnetworking.IPSubnetModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IPSubnetModify")
	}

	var r0 *clientnetworking.IPSubnetModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IPSubnetModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IPSubnetModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IPSubnetModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IPSubnetModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IPSubnetModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InterfacesMetricsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) InterfacesMetricsCollectionGet(params *clientnetworking.InterfacesMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.InterfacesMetricsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InterfacesMetricsCollectionGet")
	}

	var r0 *clientnetworking.InterfacesMetricsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.InterfacesMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.InterfacesMetricsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.InterfacesMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.InterfacesMetricsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.InterfacesMetricsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.InterfacesMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpspaceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpspaceDelete(params *clientnetworking.IpspaceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IpspaceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpspaceDelete")
	}

	var r0 *clientnetworking.IpspaceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IpspaceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IpspaceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IpspaceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IpspaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpspaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpspaceGet(params *clientnetworking.IpspaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IpspaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpspaceGet")
	}

	var r0 *clientnetworking.IpspaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IpspaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IpspaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IpspaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IpspaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpspaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpspaceModify(params *clientnetworking.IpspaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IpspaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpspaceModify")
	}

	var r0 *clientnetworking.IpspaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IpspaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IpspaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IpspaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IpspaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpspacesCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpspacesCreate(params *clientnetworking.IpspacesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IpspacesCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpspacesCreate")
	}

	var r0 *clientnetworking.IpspacesCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IpspacesCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IpspacesCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IpspacesCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IpspacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpspacesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpspacesGet(params *clientnetworking.IpspacesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.IpspacesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IpspacesGet")
	}

	var r0 *clientnetworking.IpspacesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.IpspacesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.IpspacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.IpspacesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.IpspacesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.IpspacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetBroadcastDomainDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetBroadcastDomainDelete(params *clientnetworking.NetworkEthernetBroadcastDomainDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetBroadcastDomainDelete")
	}

	var r0 *clientnetworking.NetworkEthernetBroadcastDomainDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetBroadcastDomainDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetBroadcastDomainDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetBroadcastDomainDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetBroadcastDomainGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetBroadcastDomainGet(params *clientnetworking.NetworkEthernetBroadcastDomainGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetBroadcastDomainGet")
	}

	var r0 *clientnetworking.NetworkEthernetBroadcastDomainGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetBroadcastDomainGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetBroadcastDomainGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetBroadcastDomainGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetBroadcastDomainModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetBroadcastDomainModify(params *clientnetworking.NetworkEthernetBroadcastDomainModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetBroadcastDomainModify")
	}

	var r0 *clientnetworking.NetworkEthernetBroadcastDomainModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetBroadcastDomainModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetBroadcastDomainModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetBroadcastDomainModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetBroadcastDomainsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetBroadcastDomainsCreate(params *clientnetworking.NetworkEthernetBroadcastDomainsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainsCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetBroadcastDomainsCreate")
	}

	var r0 *clientnetworking.NetworkEthernetBroadcastDomainsCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainsCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetBroadcastDomainsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetBroadcastDomainsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetBroadcastDomainsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetBroadcastDomainsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetBroadcastDomainsGet(params *clientnetworking.NetworkEthernetBroadcastDomainsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetBroadcastDomainsGet")
	}

	var r0 *clientnetworking.NetworkEthernetBroadcastDomainsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetBroadcastDomainsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetBroadcastDomainsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetBroadcastDomainsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetBroadcastDomainsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetBroadcastDomainsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetPortDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetPortDelete(params *clientnetworking.NetworkEthernetPortDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetPortDelete")
	}

	var r0 *clientnetworking.NetworkEthernetPortDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetPortDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetPortDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetPortDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetPortGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetPortGet(params *clientnetworking.NetworkEthernetPortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetPortGet")
	}

	var r0 *clientnetworking.NetworkEthernetPortGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetPortGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetPortGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetPortModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetPortModify(params *clientnetworking.NetworkEthernetPortModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetPortModify")
	}

	var r0 *clientnetworking.NetworkEthernetPortModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetPortModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetPortModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetPortModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetPortsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetPortsCreate(params *clientnetworking.NetworkEthernetPortsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortsCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetPortsCreate")
	}

	var r0 *clientnetworking.NetworkEthernetPortsCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortsCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetPortsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetPortsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetPortsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkEthernetPortsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkEthernetPortsGet(params *clientnetworking.NetworkEthernetPortsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkEthernetPortsGet")
	}

	var r0 *clientnetworking.NetworkEthernetPortsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkEthernetPortsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkEthernetPortsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkEthernetPortsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkEthernetPortsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkEthernetPortsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPBgpPeerGroupDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPBgpPeerGroupDelete(params *clientnetworking.NetworkIPBgpPeerGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPBgpPeerGroupDelete")
	}

	var r0 *clientnetworking.NetworkIPBgpPeerGroupDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPBgpPeerGroupDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPBgpPeerGroupDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPBgpPeerGroupDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPBgpPeerGroupGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPBgpPeerGroupGet(params *clientnetworking.NetworkIPBgpPeerGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPBgpPeerGroupGet")
	}

	var r0 *clientnetworking.NetworkIPBgpPeerGroupGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPBgpPeerGroupGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPBgpPeerGroupGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPBgpPeerGroupGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPBgpPeerGroupModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPBgpPeerGroupModify(params *clientnetworking.NetworkIPBgpPeerGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPBgpPeerGroupModify")
	}

	var r0 *clientnetworking.NetworkIPBgpPeerGroupModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPBgpPeerGroupModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPBgpPeerGroupModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPBgpPeerGroupModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPBgpPeerGroupsCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPBgpPeerGroupsCreate(params *clientnetworking.NetworkIPBgpPeerGroupsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupsCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPBgpPeerGroupsCreate")
	}

	var r0 *clientnetworking.NetworkIPBgpPeerGroupsCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupsCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPBgpPeerGroupsCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPBgpPeerGroupsCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPBgpPeerGroupsCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPBgpPeerGroupsGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPBgpPeerGroupsGet(params *clientnetworking.NetworkIPBgpPeerGroupsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupsGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPBgpPeerGroupsGet")
	}

	var r0 *clientnetworking.NetworkIPBgpPeerGroupsGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPBgpPeerGroupsGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPBgpPeerGroupsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPBgpPeerGroupsGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPBgpPeerGroupsGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPBgpPeerGroupsGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPInterfaceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPInterfaceDelete(params *clientnetworking.NetworkIPInterfaceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPInterfaceDelete")
	}

	var r0 *clientnetworking.NetworkIPInterfaceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPInterfaceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPInterfaceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPInterfaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPInterfaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPInterfaceGet(params *clientnetworking.NetworkIPInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPInterfaceGet")
	}

	var r0 *clientnetworking.NetworkIPInterfaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPInterfaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPInterfaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPInterfaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPInterfaceModify(params *clientnetworking.NetworkIPInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPInterfaceModify")
	}

	var r0 *clientnetworking.NetworkIPInterfaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPInterfaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPInterfaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPInterfaceModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPInterfacesCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPInterfacesCreate(params *clientnetworking.NetworkIPInterfacesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfacesCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPInterfacesCreate")
	}

	var r0 *clientnetworking.NetworkIPInterfacesCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfacesCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPInterfacesCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPInterfacesCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPInterfacesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPInterfacesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPInterfacesGet(params *clientnetworking.NetworkIPInterfacesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfacesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPInterfacesGet")
	}

	var r0 *clientnetworking.NetworkIPInterfacesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPInterfacesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPInterfacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPInterfacesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPInterfacesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPInterfacesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPRouteDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPRouteDelete(params *clientnetworking.NetworkIPRouteDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRouteDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPRouteDelete")
	}

	var r0 *clientnetworking.NetworkIPRouteDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRouteDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRouteDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRouteDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPRouteDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPRouteDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPRouteDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPRouteGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPRouteGet(params *clientnetworking.NetworkIPRouteGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRouteGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPRouteGet")
	}

	var r0 *clientnetworking.NetworkIPRouteGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRouteGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRouteGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRouteGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPRouteGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPRouteGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPRouteGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPRoutesCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPRoutesCreate(params *clientnetworking.NetworkIPRoutesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRoutesCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPRoutesCreate")
	}

	var r0 *clientnetworking.NetworkIPRoutesCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRoutesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRoutesCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRoutesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPRoutesCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPRoutesCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPRoutesCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPRoutesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPRoutesGet(params *clientnetworking.NetworkIPRoutesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRoutesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPRoutesGet")
	}

	var r0 *clientnetworking.NetworkIPRoutesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRoutesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPRoutesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPRoutesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPRoutesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPRoutesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPRoutesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPServicePoliciesGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPServicePoliciesGet(params *clientnetworking.NetworkIPServicePoliciesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPServicePoliciesGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPServicePoliciesGet")
	}

	var r0 *clientnetworking.NetworkIPServicePoliciesGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPServicePoliciesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPServicePoliciesGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPServicePoliciesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPServicePoliciesGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPServicePoliciesGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPServicePoliciesGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkIPServicePolicyGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NetworkIPServicePolicyGet(params *clientnetworking.NetworkIPServicePolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPServicePolicyGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetworkIPServicePolicyGet")
	}

	var r0 *clientnetworking.NetworkIPServicePolicyGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPServicePolicyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.NetworkIPServicePolicyGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.NetworkIPServicePolicyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.NetworkIPServicePolicyGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.NetworkIPServicePolicyGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.NetworkIPServicePolicyGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceFcInterfaceMetricCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceFcInterfaceMetricCollectionGet(params *clientnetworking.PerformanceFcInterfaceMetricCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcInterfaceMetricCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceFcInterfaceMetricCollectionGet")
	}

	var r0 *clientnetworking.PerformanceFcInterfaceMetricCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcInterfaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcInterfaceMetricCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcInterfaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.PerformanceFcInterfaceMetricCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.PerformanceFcInterfaceMetricCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.PerformanceFcInterfaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceFcInterfaceMetricGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceFcInterfaceMetricGet(params *clientnetworking.PerformanceFcInterfaceMetricGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcInterfaceMetricGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceFcInterfaceMetricGet")
	}

	var r0 *clientnetworking.PerformanceFcInterfaceMetricGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcInterfaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcInterfaceMetricGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcInterfaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.PerformanceFcInterfaceMetricGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.PerformanceFcInterfaceMetricGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.PerformanceFcInterfaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceFcPortMetricCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceFcPortMetricCollectionGet(params *clientnetworking.PerformanceFcPortMetricCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcPortMetricCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceFcPortMetricCollectionGet")
	}

	var r0 *clientnetworking.PerformanceFcPortMetricCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcPortMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcPortMetricCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcPortMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.PerformanceFcPortMetricCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.PerformanceFcPortMetricCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.PerformanceFcPortMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceFcPortMetricGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceFcPortMetricGet(params *clientnetworking.PerformanceFcPortMetricGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcPortMetricGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceFcPortMetricGet")
	}

	var r0 *clientnetworking.PerformanceFcPortMetricGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcPortMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.PerformanceFcPortMetricGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.PerformanceFcPortMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.PerformanceFcPortMetricGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.PerformanceFcPortMetricGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.PerformanceFcPortMetricGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PortMetricsCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PortMetricsCollectionGet(params *clientnetworking.PortMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.PortMetricsCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PortMetricsCollectionGet")
	}

	var r0 *clientnetworking.PortMetricsCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.PortMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.PortMetricsCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.PortMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.PortMetricsCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.PortMetricsCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.PortMetricsCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// SwitchCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchCollectionGet(params *clientnetworking.SwitchCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchCollectionGet")
	}

	var r0 *clientnetworking.SwitchCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SwitchCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchCreate(params *clientnetworking.SwitchCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchCreateCreated, *clientnetworking.SwitchCreateAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchCreate")
	}

	var r0 *clientnetworking.SwitchCreateCreated
	var r1 *clientnetworking.SwitchCreateAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchCreateCreated, *clientnetworking.SwitchCreateAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchCreateAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientnetworking.SwitchCreateAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientnetworking.SwitchCreateParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SwitchDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchDelete(params *clientnetworking.SwitchDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchDelete")
	}

	var r0 *clientnetworking.SwitchDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchDeleteParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SwitchGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchGet(params *clientnetworking.SwitchGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchGet")
	}

	var r0 *clientnetworking.SwitchGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SwitchModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchModify(params *clientnetworking.SwitchModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchModifyOK, *clientnetworking.SwitchModifyAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchModify")
	}

	var r0 *clientnetworking.SwitchModifyOK
	var r1 *clientnetworking.SwitchModifyAccepted
	var r2 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchModifyOK, *clientnetworking.SwitchModifyAccepted, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchModifyAccepted); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*clientnetworking.SwitchModifyAccepted)
		}
	}

	if rf, ok := ret.Get(2).(func(*clientnetworking.SwitchModifyParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SwitchPortCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchPortCollectionGet(params *clientnetworking.SwitchPortCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchPortCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchPortCollectionGet")
	}

	var r0 *clientnetworking.SwitchPortCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchPortCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchPortCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchPortCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchPortCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SwitchPortGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SwitchPortGet(params *clientnetworking.SwitchPortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientnetworking.ClientOption) (*clientnetworking.SwitchPortGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SwitchPortGet")
	}

	var r0 *clientnetworking.SwitchPortGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) (*clientnetworking.SwitchPortGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientnetworking.SwitchPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) *clientnetworking.SwitchPortGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientnetworking.SwitchPortGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientnetworking.SwitchPortGetParams, runtime.ClientAuthInfoWriter, ...clientnetworking.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
