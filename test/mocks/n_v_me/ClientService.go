// Code generated by mockery v2.51.0. DO NOT EDIT.

package n_v_me

import (
	clientn_v_me "github.com/metal-stack/ontap-go/api/client/n_v_me"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// NvmeInterfaceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeInterfaceCollectionGet(params *clientn_v_me.NvmeInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeInterfaceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeInterfaceCollectionGet")
	}

	var r0 *clientn_v_me.NvmeInterfaceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeInterfaceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeInterfaceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeInterfaceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeInterfaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeInterfaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeInterfaceGet(params *clientn_v_me.NvmeInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeInterfaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeInterfaceGet")
	}

	var r0 *clientn_v_me.NvmeInterfaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeInterfaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeInterfaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeInterfaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeInterfaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeNamespaceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeNamespaceCollectionGet(params *clientn_v_me.NvmeNamespaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeNamespaceCollectionGet")
	}

	var r0 *clientn_v_me.NvmeNamespaceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeNamespaceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeNamespaceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeNamespaceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeNamespaceCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeNamespaceCreate(params *clientn_v_me.NvmeNamespaceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeNamespaceCreate")
	}

	var r0 *clientn_v_me.NvmeNamespaceCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeNamespaceCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeNamespaceCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeNamespaceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeNamespaceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeNamespaceDelete(params *clientn_v_me.NvmeNamespaceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeNamespaceDelete")
	}

	var r0 *clientn_v_me.NvmeNamespaceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeNamespaceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeNamespaceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeNamespaceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeNamespaceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeNamespaceGet(params *clientn_v_me.NvmeNamespaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeNamespaceGet")
	}

	var r0 *clientn_v_me.NvmeNamespaceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeNamespaceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeNamespaceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeNamespaceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeNamespaceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeNamespaceModify(params *clientn_v_me.NvmeNamespaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeNamespaceModify")
	}

	var r0 *clientn_v_me.NvmeNamespaceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeNamespaceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeNamespaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeNamespaceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeNamespaceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeNamespaceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeServiceCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeServiceCollectionGet(params *clientn_v_me.NvmeServiceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeServiceCollectionGet")
	}

	var r0 *clientn_v_me.NvmeServiceCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeServiceCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeServiceCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeServiceCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeServiceCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeServiceCreate(params *clientn_v_me.NvmeServiceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeServiceCreate")
	}

	var r0 *clientn_v_me.NvmeServiceCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeServiceCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeServiceCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeServiceCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeServiceDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeServiceDelete(params *clientn_v_me.NvmeServiceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeServiceDelete")
	}

	var r0 *clientn_v_me.NvmeServiceDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeServiceDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeServiceDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeServiceDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeServiceGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeServiceGet(params *clientn_v_me.NvmeServiceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeServiceGet")
	}

	var r0 *clientn_v_me.NvmeServiceGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeServiceGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeServiceGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeServiceGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeServiceModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeServiceModify(params *clientn_v_me.NvmeServiceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeServiceModify")
	}

	var r0 *clientn_v_me.NvmeServiceModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeServiceModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeServiceModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeServiceModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeServiceModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemCollectionGet(params *clientn_v_me.NvmeSubsystemCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemCollectionGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemControllerCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemControllerCollectionGet(params *clientn_v_me.NvmeSubsystemControllerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemControllerCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemControllerCollectionGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemControllerCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemControllerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemControllerCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemControllerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemControllerCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemControllerCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemControllerCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemControllerGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemControllerGet(params *clientn_v_me.NvmeSubsystemControllerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemControllerGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemControllerGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemControllerGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemControllerGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemControllerGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemControllerGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemControllerGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemControllerGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemControllerGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemCreate(params *clientn_v_me.NvmeSubsystemCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemCreate")
	}

	var r0 *clientn_v_me.NvmeSubsystemCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemDelete(params *clientn_v_me.NvmeSubsystemDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemDelete")
	}

	var r0 *clientn_v_me.NvmeSubsystemDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemGet(params *clientn_v_me.NvmeSubsystemGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemHostCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemHostCollectionGet(params *clientn_v_me.NvmeSubsystemHostCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemHostCollectionGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemHostCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemHostCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemHostCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemHostCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemHostCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemHostCreate(params *clientn_v_me.NvmeSubsystemHostCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemHostCreate")
	}

	var r0 *clientn_v_me.NvmeSubsystemHostCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemHostCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemHostCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemHostCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemHostDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemHostDelete(params *clientn_v_me.NvmeSubsystemHostDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemHostDelete")
	}

	var r0 *clientn_v_me.NvmeSubsystemHostDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemHostDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemHostDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemHostDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemHostGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemHostGet(params *clientn_v_me.NvmeSubsystemHostGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemHostGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemHostGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemHostGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemHostGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemHostGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemHostGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemHostGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemMapCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemMapCollectionGet(params *clientn_v_me.NvmeSubsystemMapCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemMapCollectionGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemMapCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemMapCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemMapCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemMapCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemMapCreate provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemMapCreate(params *clientn_v_me.NvmeSubsystemMapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapCreateCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemMapCreate")
	}

	var r0 *clientn_v_me.NvmeSubsystemMapCreateCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapCreateCreated, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemMapCreateCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemMapCreateCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemMapCreateParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemMapDelete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemMapDelete(params *clientn_v_me.NvmeSubsystemMapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapDeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemMapDelete")
	}

	var r0 *clientn_v_me.NvmeSubsystemMapDeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapDeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemMapDeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemMapDeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemMapDeleteParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemMapGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemMapGet(params *clientn_v_me.NvmeSubsystemMapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemMapGet")
	}

	var r0 *clientn_v_me.NvmeSubsystemMapGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemMapGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemMapGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemMapGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemMapGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NvmeSubsystemModify provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NvmeSubsystemModify(params *clientn_v_me.NvmeSubsystemModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemModifyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NvmeSubsystemModify")
	}

	var r0 *clientn_v_me.NvmeSubsystemModifyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.NvmeSubsystemModifyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.NvmeSubsystemModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.NvmeSubsystemModifyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.NvmeSubsystemModifyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.NvmeSubsystemModifyParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceNamespaceMetricCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceNamespaceMetricCollectionGet(params *clientn_v_me.PerformanceNamespaceMetricCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNamespaceMetricCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceNamespaceMetricCollectionGet")
	}

	var r0 *clientn_v_me.PerformanceNamespaceMetricCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNamespaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNamespaceMetricCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNamespaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.PerformanceNamespaceMetricCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.PerformanceNamespaceMetricCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.PerformanceNamespaceMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceNamespaceMetricGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceNamespaceMetricGet(params *clientn_v_me.PerformanceNamespaceMetricGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNamespaceMetricGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceNamespaceMetricGet")
	}

	var r0 *clientn_v_me.PerformanceNamespaceMetricGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNamespaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNamespaceMetricGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNamespaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.PerformanceNamespaceMetricGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.PerformanceNamespaceMetricGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.PerformanceNamespaceMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceNvmeMetricCollectionGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceNvmeMetricCollectionGet(params *clientn_v_me.PerformanceNvmeMetricCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNvmeMetricCollectionGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceNvmeMetricCollectionGet")
	}

	var r0 *clientn_v_me.PerformanceNvmeMetricCollectionGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNvmeMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNvmeMetricCollectionGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNvmeMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.PerformanceNvmeMetricCollectionGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.PerformanceNvmeMetricCollectionGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.PerformanceNvmeMetricCollectionGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformanceNvmeMetricGet provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PerformanceNvmeMetricGet(params *clientn_v_me.PerformanceNvmeMetricGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNvmeMetricGetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PerformanceNvmeMetricGet")
	}

	var r0 *clientn_v_me.PerformanceNvmeMetricGetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNvmeMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) (*clientn_v_me.PerformanceNvmeMetricGetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*clientn_v_me.PerformanceNvmeMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) *clientn_v_me.PerformanceNvmeMetricGetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clientn_v_me.PerformanceNvmeMetricGetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*clientn_v_me.PerformanceNvmeMetricGetParams, runtime.ClientAuthInfoWriter, ...clientn_v_me.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
