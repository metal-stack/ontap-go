// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Application Applications
//
// swagger:model application
type Application struct {

	// links
	Links *ApplicationLinks `json:"_links,omitempty" yaml:"_links,omitempty"`

	// The time when the application was created.
	// Read Only: true
	CreationTimestamp string `json:"creation_timestamp,omitempty" yaml:"creation_timestamp,omitempty"`

	// Should application storage elements be deleted? An application is considered to use storage elements from a shared storage pool. Possible values are 'true' and 'false'. If the value is 'true', the application will be deleted in its entirety. If the value is 'false', the storage elements will be disassociated from the application and preserved. The application will then be deleted.
	DeleteData *bool `json:"delete_data,omitempty" yaml:"delete_data,omitempty"`

	// The generation number of the application. This indicates which features are supported on the application. For example, generation 1 applications do not support Snapshot copies. Support for Snapshot copies was added at generation 2. Any future generation numbers and their feature set will be documented.
	// Read Only: true
	Generation int64 `json:"generation,omitempty" yaml:"generation,omitempty"`

	// mongo db on san
	MongoDbOnSan *MongoDbOnSan `json:"mongo_db_on_san,omitempty" yaml:"mongo_db_on_san,omitempty"`

	// Application Name. This field is user supplied when the application is created.
	// Required: true
	Name *string `json:"name" yaml:"name"`

	// nas
	Nas *Nas `json:"nas,omitempty" yaml:"nas,omitempty"`

	// nvme
	Nvme *ZappNvme `json:"nvme,omitempty" yaml:"nvme,omitempty"`

	// oracle on nfs
	OracleOnNfs *OracleOnNfs `json:"oracle_on_nfs,omitempty" yaml:"oracle_on_nfs,omitempty"`

	// oracle on san
	OracleOnSan *OracleOnSan `json:"oracle_on_san,omitempty" yaml:"oracle_on_san,omitempty"`

	// oracle rac on nfs
	OracleRacOnNfs *OracleRacOnNfs `json:"oracle_rac_on_nfs,omitempty" yaml:"oracle_rac_on_nfs,omitempty"`

	// oracle rac on san
	OracleRacOnSan *OracleRacOnSan `json:"oracle_rac_on_san,omitempty" yaml:"oracle_rac_on_san,omitempty"`

	// Protection granularity determines the scope of Snapshot copy operations for the application. Possible values are "application" and "component". If the value is "application", Snapshot copy operations are performed on the entire application. If the value is "component", Snapshot copy operations are performed separately on the application components.
	// Read Only: true
	// Enum: ["application","component"]
	ProtectionGranularity string `json:"protection_granularity,omitempty" yaml:"protection_granularity,omitempty"`

	// rpo
	Rpo *ApplicationRpo `json:"rpo,omitempty" yaml:"rpo,omitempty"`

	// s3 bucket
	S3Bucket *ZappS3Bucket `json:"s3_bucket,omitempty" yaml:"s3_bucket,omitempty"`

	// san
	San *San `json:"san,omitempty" yaml:"san,omitempty"`

	// Identifies if this is a smart container or not.
	SmartContainer bool `json:"smart_container,omitempty" yaml:"smart_container,omitempty"`

	// sql on san
	SQLOnSan *SQLOnSan `json:"sql_on_san,omitempty" yaml:"sql_on_san,omitempty"`

	// sql on smb
	SQLOnSmb *SQLOnSmb `json:"sql_on_smb,omitempty" yaml:"sql_on_smb,omitempty"`

	// The state of the application. For full functionality, applications must be in the online state. Other states indicate that the application is in a transient state and not all operations are supported.
	// Read Only: true
	// Enum: ["creating","deleting","modifying","online","restoring"]
	State string `json:"state,omitempty" yaml:"state,omitempty"`

	// statistics
	Statistics *ApplicationStatistics `json:"statistics,omitempty" yaml:"statistics,omitempty"`

	// svm
	Svm *ApplicationSvm `json:"svm,omitempty" yaml:"svm,omitempty"`

	// template
	Template *ApplicationTemplate `json:"template,omitempty" yaml:"template,omitempty"`

	// Application UUID. This field is generated when the application is created.
	// Read Only: true
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`

	// vdi on nas
	VdiOnNas *VdiOnNas `json:"vdi_on_nas,omitempty" yaml:"vdi_on_nas,omitempty"`

	// vdi on san
	VdiOnSan *VdiOnSan `json:"vdi_on_san,omitempty" yaml:"vdi_on_san,omitempty"`

	// vsi on nas
	VsiOnNas *VsiOnNas `json:"vsi_on_nas,omitempty" yaml:"vsi_on_nas,omitempty"`

	// vsi on san
	VsiOnSan *VsiOnSan `json:"vsi_on_san,omitempty" yaml:"vsi_on_san,omitempty"`
}

// Validate validates this application
func (m *Application) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMongoDbOnSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOracleOnNfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOracleOnSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOracleRacOnNfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOracleRacOnSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionGranularity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRpo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3Bucket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLOnSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLOnSmb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdiOnNas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdiOnSan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVsiOnNas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVsiOnSan(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Application) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateMongoDbOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.MongoDbOnSan) { // not required
		return nil
	}

	if m.MongoDbOnSan != nil {
		if err := m.MongoDbOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mongo_db_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mongo_db_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Application) validateNas(formats strfmt.Registry) error {
	if swag.IsZero(m.Nas) { // not required
		return nil
	}

	if m.Nas != nil {
		if err := m.Nas.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateNvme(formats strfmt.Registry) error {
	if swag.IsZero(m.Nvme) { // not required
		return nil
	}

	if m.Nvme != nil {
		if err := m.Nvme.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateOracleOnNfs(formats strfmt.Registry) error {
	if swag.IsZero(m.OracleOnNfs) { // not required
		return nil
	}

	if m.OracleOnNfs != nil {
		if err := m.OracleOnNfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_on_nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_on_nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateOracleOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.OracleOnSan) { // not required
		return nil
	}

	if m.OracleOnSan != nil {
		if err := m.OracleOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateOracleRacOnNfs(formats strfmt.Registry) error {
	if swag.IsZero(m.OracleRacOnNfs) { // not required
		return nil
	}

	if m.OracleRacOnNfs != nil {
		if err := m.OracleRacOnNfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_rac_on_nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_rac_on_nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateOracleRacOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.OracleRacOnSan) { // not required
		return nil
	}

	if m.OracleRacOnSan != nil {
		if err := m.OracleRacOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_rac_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_rac_on_san")
			}
			return err
		}
	}

	return nil
}

var applicationTypeProtectionGranularityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["application","component"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeProtectionGranularityPropEnum = append(applicationTypeProtectionGranularityPropEnum, v)
	}
}

const (

	// ApplicationProtectionGranularityApplication captures enum value "application"
	ApplicationProtectionGranularityApplication string = "application"

	// ApplicationProtectionGranularityComponent captures enum value "component"
	ApplicationProtectionGranularityComponent string = "component"
)

// prop value enum
func (m *Application) validateProtectionGranularityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeProtectionGranularityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateProtectionGranularity(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionGranularity) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionGranularityEnum("protection_granularity", "body", m.ProtectionGranularity); err != nil {
		return err
	}

	return nil
}

func (m *Application) validateRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.Rpo) { // not required
		return nil
	}

	if m.Rpo != nil {
		if err := m.Rpo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateS3Bucket(formats strfmt.Registry) error {
	if swag.IsZero(m.S3Bucket) { // not required
		return nil
	}

	if m.S3Bucket != nil {
		if err := m.S3Bucket.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3_bucket")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3_bucket")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateSan(formats strfmt.Registry) error {
	if swag.IsZero(m.San) { // not required
		return nil
	}

	if m.San != nil {
		if err := m.San.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateSQLOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLOnSan) { // not required
		return nil
	}

	if m.SQLOnSan != nil {
		if err := m.SQLOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sql_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sql_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateSQLOnSmb(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLOnSmb) { // not required
		return nil
	}

	if m.SQLOnSmb != nil {
		if err := m.SQLOnSmb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sql_on_smb")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sql_on_smb")
			}
			return err
		}
	}

	return nil
}

var applicationTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["creating","deleting","modifying","online","restoring"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeStatePropEnum = append(applicationTypeStatePropEnum, v)
	}
}

const (

	// ApplicationStateCreating captures enum value "creating"
	ApplicationStateCreating string = "creating"

	// ApplicationStateDeleting captures enum value "deleting"
	ApplicationStateDeleting string = "deleting"

	// ApplicationStateModifying captures enum value "modifying"
	ApplicationStateModifying string = "modifying"

	// ApplicationStateOnline captures enum value "online"
	ApplicationStateOnline string = "online"

	// ApplicationStateRestoring captures enum value "restoring"
	ApplicationStateRestoring string = "restoring"
)

// prop value enum
func (m *Application) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Application) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateTemplate(formats strfmt.Registry) error {
	if swag.IsZero(m.Template) { // not required
		return nil
	}

	if m.Template != nil {
		if err := m.Template.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("template")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("template")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateVdiOnNas(formats strfmt.Registry) error {
	if swag.IsZero(m.VdiOnNas) { // not required
		return nil
	}

	if m.VdiOnNas != nil {
		if err := m.VdiOnNas.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdi_on_nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdi_on_nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateVdiOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.VdiOnSan) { // not required
		return nil
	}

	if m.VdiOnSan != nil {
		if err := m.VdiOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdi_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdi_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateVsiOnNas(formats strfmt.Registry) error {
	if swag.IsZero(m.VsiOnNas) { // not required
		return nil
	}

	if m.VsiOnNas != nil {
		if err := m.VsiOnNas.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsi_on_nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsi_on_nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) validateVsiOnSan(formats strfmt.Registry) error {
	if swag.IsZero(m.VsiOnSan) { // not required
		return nil
	}

	if m.VsiOnSan != nil {
		if err := m.VsiOnSan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsi_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsi_on_san")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application based on the context it is used
func (m *Application) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreationTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMongoDbOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvme(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOracleOnNfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOracleOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOracleRacOnNfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOracleRacOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionGranularity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRpo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3Bucket(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLOnSmb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTemplate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdiOnNas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdiOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVsiOnNas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVsiOnSan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Application) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateCreationTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "creation_timestamp", "body", string(m.CreationTimestamp)); err != nil {
		return err
	}

	return nil
}

func (m *Application) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *Application) contextValidateMongoDbOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.MongoDbOnSan != nil {

		if swag.IsZero(m.MongoDbOnSan) { // not required
			return nil
		}

		if err := m.MongoDbOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mongo_db_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mongo_db_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateNas(ctx context.Context, formats strfmt.Registry) error {

	if m.Nas != nil {

		if swag.IsZero(m.Nas) { // not required
			return nil
		}

		if err := m.Nas.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateNvme(ctx context.Context, formats strfmt.Registry) error {

	if m.Nvme != nil {

		if swag.IsZero(m.Nvme) { // not required
			return nil
		}

		if err := m.Nvme.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateOracleOnNfs(ctx context.Context, formats strfmt.Registry) error {

	if m.OracleOnNfs != nil {

		if swag.IsZero(m.OracleOnNfs) { // not required
			return nil
		}

		if err := m.OracleOnNfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_on_nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_on_nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateOracleOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.OracleOnSan != nil {

		if swag.IsZero(m.OracleOnSan) { // not required
			return nil
		}

		if err := m.OracleOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateOracleRacOnNfs(ctx context.Context, formats strfmt.Registry) error {

	if m.OracleRacOnNfs != nil {

		if swag.IsZero(m.OracleRacOnNfs) { // not required
			return nil
		}

		if err := m.OracleRacOnNfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_rac_on_nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_rac_on_nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateOracleRacOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.OracleRacOnSan != nil {

		if swag.IsZero(m.OracleRacOnSan) { // not required
			return nil
		}

		if err := m.OracleRacOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracle_rac_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracle_rac_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateProtectionGranularity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "protection_granularity", "body", string(m.ProtectionGranularity)); err != nil {
		return err
	}

	return nil
}

func (m *Application) contextValidateRpo(ctx context.Context, formats strfmt.Registry) error {

	if m.Rpo != nil {

		if swag.IsZero(m.Rpo) { // not required
			return nil
		}

		if err := m.Rpo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateS3Bucket(ctx context.Context, formats strfmt.Registry) error {

	if m.S3Bucket != nil {

		if swag.IsZero(m.S3Bucket) { // not required
			return nil
		}

		if err := m.S3Bucket.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3_bucket")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3_bucket")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateSan(ctx context.Context, formats strfmt.Registry) error {

	if m.San != nil {

		if swag.IsZero(m.San) { // not required
			return nil
		}

		if err := m.San.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateSQLOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLOnSan != nil {

		if swag.IsZero(m.SQLOnSan) { // not required
			return nil
		}

		if err := m.SQLOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sql_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sql_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateSQLOnSmb(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLOnSmb != nil {

		if swag.IsZero(m.SQLOnSmb) { // not required
			return nil
		}

		if err := m.SQLOnSmb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sql_on_smb")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sql_on_smb")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Application) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {

		if swag.IsZero(m.Statistics) { // not required
			return nil
		}

		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {

		if swag.IsZero(m.Svm) { // not required
			return nil
		}

		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateTemplate(ctx context.Context, formats strfmt.Registry) error {

	if m.Template != nil {

		if swag.IsZero(m.Template) { // not required
			return nil
		}

		if err := m.Template.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("template")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("template")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Application) contextValidateVdiOnNas(ctx context.Context, formats strfmt.Registry) error {

	if m.VdiOnNas != nil {

		if swag.IsZero(m.VdiOnNas) { // not required
			return nil
		}

		if err := m.VdiOnNas.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdi_on_nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdi_on_nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateVdiOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.VdiOnSan != nil {

		if swag.IsZero(m.VdiOnSan) { // not required
			return nil
		}

		if err := m.VdiOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdi_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdi_on_san")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateVsiOnNas(ctx context.Context, formats strfmt.Registry) error {

	if m.VsiOnNas != nil {

		if swag.IsZero(m.VsiOnNas) { // not required
			return nil
		}

		if err := m.VsiOnNas.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsi_on_nas")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsi_on_nas")
			}
			return err
		}
	}

	return nil
}

func (m *Application) contextValidateVsiOnSan(ctx context.Context, formats strfmt.Registry) error {

	if m.VsiOnSan != nil {

		if swag.IsZero(m.VsiOnSan) { // not required
			return nil
		}

		if err := m.VsiOnSan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsi_on_san")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsi_on_san")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Application) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Application) UnmarshalBinary(b []byte) error {
	var res Application
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationLinks application links
//
// swagger:model ApplicationLinks
type ApplicationLinks struct {

	// self
	Self *Href `json:"self,omitempty" yaml:"self,omitempty"`

	// snapshots
	Snapshots *Href `json:"snapshots,omitempty" yaml:"snapshots,omitempty"`
}

// Validate validates this application links
func (m *ApplicationLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationLinks) validateSnapshots(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshots) { // not required
		return nil
	}

	if m.Snapshots != nil {
		if err := m.Snapshots.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "snapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "snapshots")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application links based on the context it is used
func (m *ApplicationLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationLinks) contextValidateSnapshots(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshots != nil {

		if swag.IsZero(m.Snapshots) { // not required
			return nil
		}

		if err := m.Snapshots.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "snapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "snapshots")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationLinks) UnmarshalBinary(b []byte) error {
	var res ApplicationLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpo application rpo
//
// swagger:model ApplicationRpo
type ApplicationRpo struct {

	// components
	// Read Only: true
	Components []*ApplicationRpoComponentsItems0 `json:"components" yaml:"components"`

	// Is RPO supported for this application? Generation 1 applications did not support Snapshot copies or MetroCluster.
	// Read Only: true
	IsSupported *bool `json:"is_supported,omitempty" yaml:"is_supported,omitempty"`

	// local
	Local *ApplicationRpoLocal `json:"local,omitempty" yaml:"local,omitempty"`

	// remote
	Remote *ApplicationRpoRemote `json:"remote,omitempty" yaml:"remote,omitempty"`
}

// Validate validates this application rpo
func (m *ApplicationRpo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpo) validateComponents(formats strfmt.Registry) error {
	if swag.IsZero(m.Components) { // not required
		return nil
	}

	for i := 0; i < len(m.Components); i++ {
		if swag.IsZero(m.Components[i]) { // not required
			continue
		}

		if m.Components[i] != nil {
			if err := m.Components[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rpo" + "." + "components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rpo" + "." + "components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationRpo) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationRpo) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application rpo based on the context it is used
func (m *ApplicationRpo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSupported(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpo) contextValidateComponents(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"components", "body", []*ApplicationRpoComponentsItems0(m.Components)); err != nil {
		return err
	}

	for i := 0; i < len(m.Components); i++ {

		if m.Components[i] != nil {

			if swag.IsZero(m.Components[i]) { // not required
				return nil
			}

			if err := m.Components[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rpo" + "." + "components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rpo" + "." + "components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationRpo) contextValidateIsSupported(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"is_supported", "body", m.IsSupported); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpo) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {

		if swag.IsZero(m.Local) { // not required
			return nil
		}

		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationRpo) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {

		if swag.IsZero(m.Remote) { // not required
			return nil
		}

		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpo) UnmarshalBinary(b []byte) error {
	var res ApplicationRpo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoComponentsItems0 application rpo components items0
//
// swagger:model ApplicationRpoComponentsItems0
type ApplicationRpoComponentsItems0 struct {

	// Component Name.
	// Read Only: true
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// rpo
	Rpo *ApplicationRpoComponentsItems0Rpo `json:"rpo,omitempty" yaml:"rpo,omitempty"`

	// Component UUID.
	// Read Only: true
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this application rpo components items0
func (m *ApplicationRpoComponentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRpo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0) validateRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.Rpo) { // not required
		return nil
	}

	if m.Rpo != nil {
		if err := m.Rpo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application rpo components items0 based on the context it is used
func (m *ApplicationRpoComponentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRpo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0) contextValidateRpo(ctx context.Context, formats strfmt.Registry) error {

	if m.Rpo != nil {

		if swag.IsZero(m.Rpo) { // not required
			return nil
		}

		if err := m.Rpo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoComponentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoComponentsItems0Rpo application rpo components items0 rpo
//
// swagger:model ApplicationRpoComponentsItems0Rpo
type ApplicationRpoComponentsItems0Rpo struct {

	// local
	Local *ApplicationRpoComponentsItems0RpoLocal `json:"local,omitempty" yaml:"local,omitempty"`

	// remote
	Remote *ApplicationRpoComponentsItems0RpoRemote `json:"remote,omitempty" yaml:"remote,omitempty"`
}

// Validate validates this application rpo components items0 rpo
func (m *ApplicationRpoComponentsItems0Rpo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0Rpo) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0Rpo) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application rpo components items0 rpo based on the context it is used
func (m *ApplicationRpoComponentsItems0Rpo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0Rpo) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {

		if swag.IsZero(m.Local) { // not required
			return nil
		}

		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0Rpo) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {

		if swag.IsZero(m.Remote) { // not required
			return nil
		}

		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0Rpo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0Rpo) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoComponentsItems0Rpo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoComponentsItems0RpoLocal application rpo components items0 rpo local
//
// swagger:model ApplicationRpoComponentsItems0RpoLocal
type ApplicationRpoComponentsItems0RpoLocal struct {

	// A detailed description of the local RPO. This will include details about the Snapshot copy schedule.
	// Read Only: true
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// The local RPO of the component. This indicates how often component Snapshot copies are automatically created.
	// Read Only: true
	// Enum: ["6_hourly","15_minutely","hourly","none"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this application rpo components items0 rpo local
func (m *ApplicationRpoComponentsItems0RpoLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var applicationRpoComponentsItems0RpoLocalTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["6_hourly","15_minutely","hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationRpoComponentsItems0RpoLocalTypeNamePropEnum = append(applicationRpoComponentsItems0RpoLocalTypeNamePropEnum, v)
	}
}

const (

	// ApplicationRpoComponentsItems0RpoLocalNameNr6Hourly captures enum value "6_hourly"
	ApplicationRpoComponentsItems0RpoLocalNameNr6Hourly string = "6_hourly"

	// ApplicationRpoComponentsItems0RpoLocalNameNr15Minutely captures enum value "15_minutely"
	ApplicationRpoComponentsItems0RpoLocalNameNr15Minutely string = "15_minutely"

	// ApplicationRpoComponentsItems0RpoLocalNameHourly captures enum value "hourly"
	ApplicationRpoComponentsItems0RpoLocalNameHourly string = "hourly"

	// ApplicationRpoComponentsItems0RpoLocalNameNone captures enum value "none"
	ApplicationRpoComponentsItems0RpoLocalNameNone string = "none"
)

// prop value enum
func (m *ApplicationRpoComponentsItems0RpoLocal) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationRpoComponentsItems0RpoLocalTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0RpoLocal) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"local"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application rpo components items0 rpo local based on the context it is used
func (m *ApplicationRpoComponentsItems0RpoLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0RpoLocal) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"local"+"."+"description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0RpoLocal) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"local"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0RpoLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0RpoLocal) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoComponentsItems0RpoLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoComponentsItems0RpoRemote application rpo components items0 rpo remote
//
// swagger:model ApplicationRpoComponentsItems0RpoRemote
type ApplicationRpoComponentsItems0RpoRemote struct {

	// A detailed description of the remote RPO.
	// Read Only: true
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// The remote RPO of the component. A remote RPO of zero indicates that the component is synchronously replicated to another cluster.
	// Read Only: true
	// Enum: ["6_hourly","15_minutely","hourly","none","zero"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this application rpo components items0 rpo remote
func (m *ApplicationRpoComponentsItems0RpoRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var applicationRpoComponentsItems0RpoRemoteTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["6_hourly","15_minutely","hourly","none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationRpoComponentsItems0RpoRemoteTypeNamePropEnum = append(applicationRpoComponentsItems0RpoRemoteTypeNamePropEnum, v)
	}
}

const (

	// ApplicationRpoComponentsItems0RpoRemoteNameNr6Hourly captures enum value "6_hourly"
	ApplicationRpoComponentsItems0RpoRemoteNameNr6Hourly string = "6_hourly"

	// ApplicationRpoComponentsItems0RpoRemoteNameNr15Minutely captures enum value "15_minutely"
	ApplicationRpoComponentsItems0RpoRemoteNameNr15Minutely string = "15_minutely"

	// ApplicationRpoComponentsItems0RpoRemoteNameHourly captures enum value "hourly"
	ApplicationRpoComponentsItems0RpoRemoteNameHourly string = "hourly"

	// ApplicationRpoComponentsItems0RpoRemoteNameNone captures enum value "none"
	ApplicationRpoComponentsItems0RpoRemoteNameNone string = "none"

	// ApplicationRpoComponentsItems0RpoRemoteNameZero captures enum value "zero"
	ApplicationRpoComponentsItems0RpoRemoteNameZero string = "zero"
)

// prop value enum
func (m *ApplicationRpoComponentsItems0RpoRemote) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationRpoComponentsItems0RpoRemoteTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0RpoRemote) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"remote"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application rpo components items0 rpo remote based on the context it is used
func (m *ApplicationRpoComponentsItems0RpoRemote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoComponentsItems0RpoRemote) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"remote"+"."+"description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpoComponentsItems0RpoRemote) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"remote"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0RpoRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoComponentsItems0RpoRemote) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoComponentsItems0RpoRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoLocal application rpo local
//
// swagger:model ApplicationRpoLocal
type ApplicationRpoLocal struct {

	// A detailed description of the local RPO. This will include details about the Snapshot copy schedule.
	// Read Only: true
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// The local RPO of the application. This indicates how often application Snapshot copies are automatically created.
	// Read Only: true
	// Enum: ["6_hourly","15_minutely","hourly","none"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this application rpo local
func (m *ApplicationRpoLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var applicationRpoLocalTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["6_hourly","15_minutely","hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationRpoLocalTypeNamePropEnum = append(applicationRpoLocalTypeNamePropEnum, v)
	}
}

const (

	// ApplicationRpoLocalNameNr6Hourly captures enum value "6_hourly"
	ApplicationRpoLocalNameNr6Hourly string = "6_hourly"

	// ApplicationRpoLocalNameNr15Minutely captures enum value "15_minutely"
	ApplicationRpoLocalNameNr15Minutely string = "15_minutely"

	// ApplicationRpoLocalNameHourly captures enum value "hourly"
	ApplicationRpoLocalNameHourly string = "hourly"

	// ApplicationRpoLocalNameNone captures enum value "none"
	ApplicationRpoLocalNameNone string = "none"
)

// prop value enum
func (m *ApplicationRpoLocal) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationRpoLocalTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationRpoLocal) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"local"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application rpo local based on the context it is used
func (m *ApplicationRpoLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoLocal) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"local"+"."+"description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpoLocal) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"local"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoLocal) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationRpoRemote application rpo remote
//
// swagger:model ApplicationRpoRemote
type ApplicationRpoRemote struct {

	// A detailed description of the remote RPO.
	// Read Only: true
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// The remote RPO of the application. A remote RPO of zero indicates that the application is synchronously replicated to another cluster.
	// Read Only: true
	// Enum: ["6_hourly","15_minutely","hourly","none","zero"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this application rpo remote
func (m *ApplicationRpoRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var applicationRpoRemoteTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["6_hourly","15_minutely","hourly","none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationRpoRemoteTypeNamePropEnum = append(applicationRpoRemoteTypeNamePropEnum, v)
	}
}

const (

	// ApplicationRpoRemoteNameNr6Hourly captures enum value "6_hourly"
	ApplicationRpoRemoteNameNr6Hourly string = "6_hourly"

	// ApplicationRpoRemoteNameNr15Minutely captures enum value "15_minutely"
	ApplicationRpoRemoteNameNr15Minutely string = "15_minutely"

	// ApplicationRpoRemoteNameHourly captures enum value "hourly"
	ApplicationRpoRemoteNameHourly string = "hourly"

	// ApplicationRpoRemoteNameNone captures enum value "none"
	ApplicationRpoRemoteNameNone string = "none"

	// ApplicationRpoRemoteNameZero captures enum value "zero"
	ApplicationRpoRemoteNameZero string = "zero"
)

// prop value enum
func (m *ApplicationRpoRemote) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationRpoRemoteTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationRpoRemote) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"remote"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application rpo remote based on the context it is used
func (m *ApplicationRpoRemote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationRpoRemote) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"remote"+"."+"description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationRpoRemote) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpo"+"."+"remote"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationRpoRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationRpoRemote) UnmarshalBinary(b []byte) error {
	var res ApplicationRpoRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatistics application statistics
//
// swagger:model ApplicationStatistics
type ApplicationStatistics struct {

	// components
	// Read Only: true
	Components []*ApplicationStatisticsComponentsItems0 `json:"components" yaml:"components"`

	// iops
	Iops *ApplicationStatisticsIops `json:"iops,omitempty" yaml:"iops,omitempty"`

	// latency
	Latency *ApplicationStatisticsLatency `json:"latency,omitempty" yaml:"latency,omitempty"`

	// An application is considered to use a shared storage pool if storage elements for multiple components reside on the same aggregate.
	// Read Only: true
	SharedStoragePool *bool `json:"shared_storage_pool,omitempty" yaml:"shared_storage_pool,omitempty"`

	// snapshot
	Snapshot *ApplicationStatisticsSnapshot `json:"snapshot,omitempty" yaml:"snapshot,omitempty"`

	// space
	Space *ApplicationStatisticsSpace `json:"space,omitempty" yaml:"space,omitempty"`

	// If not all storage elements of the application are currently available, the returned statistics might only include data from those elements that were available.
	// Read Only: true
	StatisticsIncomplete *bool `json:"statistics_incomplete,omitempty" yaml:"statistics_incomplete,omitempty"`
}

// Validate validates this application statistics
func (m *ApplicationStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatistics) validateComponents(formats strfmt.Registry) error {
	if swag.IsZero(m.Components) { // not required
		return nil
	}

	for i := 0; i < len(m.Components); i++ {
		if swag.IsZero(m.Components[i]) { // not required
			continue
		}

		if m.Components[i] != nil {
			if err := m.Components[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("statistics" + "." + "components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("statistics" + "." + "components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationStatistics) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "snapshot")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "space")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "space")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application statistics based on the context it is used
func (m *ApplicationStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSharedStoragePool(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatisticsIncomplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatistics) contextValidateComponents(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"components", "body", []*ApplicationStatisticsComponentsItems0(m.Components)); err != nil {
		return err
	}

	for i := 0; i < len(m.Components); i++ {

		if m.Components[i] != nil {

			if swag.IsZero(m.Components[i]) { // not required
				return nil
			}

			if err := m.Components[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("statistics" + "." + "components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("statistics" + "." + "components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationStatistics) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {

		if swag.IsZero(m.Iops) { // not required
			return nil
		}

		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {

		if swag.IsZero(m.Latency) { // not required
			return nil
		}

		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) contextValidateSharedStoragePool(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"shared_storage_pool", "body", m.SharedStoragePool); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatistics) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {

		if swag.IsZero(m.Snapshot) { // not required
			return nil
		}

		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "snapshot")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {

		if swag.IsZero(m.Space) { // not required
			return nil
		}

		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "space")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics" + "." + "space")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatistics) contextValidateStatisticsIncomplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"statistics_incomplete", "body", m.StatisticsIncomplete); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatistics) UnmarshalBinary(b []byte) error {
	var res ApplicationStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0 application statistics components items0
//
// swagger:model ApplicationStatisticsComponentsItems0
type ApplicationStatisticsComponentsItems0 struct {

	// iops
	Iops *ApplicationStatisticsComponentsItems0Iops `json:"iops,omitempty" yaml:"iops,omitempty"`

	// latency
	Latency *ApplicationStatisticsComponentsItems0Latency `json:"latency,omitempty" yaml:"latency,omitempty"`

	// Component Name.
	// Read Only: true
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// An application component is considered to use a shared storage pool if storage elements for for other components reside on the same aggregate as storage elements for this component.
	// Read Only: true
	SharedStoragePool *bool `json:"shared_storage_pool,omitempty" yaml:"shared_storage_pool,omitempty"`

	// snapshot
	Snapshot *ApplicationStatisticsComponentsItems0Snapshot `json:"snapshot,omitempty" yaml:"snapshot,omitempty"`

	// space
	Space *ApplicationStatisticsComponentsItems0Space `json:"space,omitempty" yaml:"space,omitempty"`

	// If not all storage elements of the application component are currently available, the returned statistics might only include data from those elements that were available.
	// Read Only: true
	StatisticsIncomplete *bool `json:"statistics_incomplete,omitempty" yaml:"statistics_incomplete,omitempty"`

	// storage service
	StorageService *ApplicationStatisticsComponentsItems0StorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`

	// Component UUID.
	// Read Only: true
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this application statistics components items0
func (m *ApplicationStatisticsComponentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application statistics components items0 based on the context it is used
func (m *ApplicationStatisticsComponentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSharedStoragePool(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatisticsIncomplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {

		if swag.IsZero(m.Iops) { // not required
			return nil
		}

		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {

		if swag.IsZero(m.Latency) { // not required
			return nil
		}

		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateSharedStoragePool(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "shared_storage_pool", "body", m.SharedStoragePool); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {

		if swag.IsZero(m.Snapshot) { // not required
			return nil
		}

		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {

		if swag.IsZero(m.Space) { // not required
			return nil
		}

		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateStatisticsIncomplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics_incomplete", "body", m.StatisticsIncomplete); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0Iops application statistics components items0 iops
//
// swagger:model ApplicationStatisticsComponentsItems0Iops
type ApplicationStatisticsComponentsItems0Iops struct {

	// The number of IOPS per terabyte of logical space currently being used by the application component.
	// Read Only: true
	PerTb int64 `json:"per_tb,omitempty" yaml:"per_tb,omitempty"`

	// The total number of IOPS being used by the application component.
	// Read Only: true
	Total int64 `json:"total,omitempty" yaml:"total,omitempty"`
}

// Validate validates this application statistics components items0 iops
func (m *ApplicationStatisticsComponentsItems0Iops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics components items0 iops based on the context it is used
func (m *ApplicationStatisticsComponentsItems0Iops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePerTb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0Iops) contextValidatePerTb(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "iops"+"."+"per_tb", "body", int64(m.PerTb)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Iops) contextValidateTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "iops"+"."+"total", "body", int64(m.Total)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Iops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Iops) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0Iops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0Latency application statistics components items0 latency
//
// swagger:model ApplicationStatisticsComponentsItems0Latency
type ApplicationStatisticsComponentsItems0Latency struct {

	// The cumulative average response time in microseconds for this component.
	// Read Only: true
	Average int64 `json:"average,omitempty" yaml:"average,omitempty"`

	// The cumulative response time in microseconds for this component.
	// Read Only: true
	Raw int64 `json:"raw,omitempty" yaml:"raw,omitempty"`
}

// Validate validates this application statistics components items0 latency
func (m *ApplicationStatisticsComponentsItems0Latency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics components items0 latency based on the context it is used
func (m *ApplicationStatisticsComponentsItems0Latency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAverage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0Latency) contextValidateAverage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "latency"+"."+"average", "body", int64(m.Average)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Latency) contextValidateRaw(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "latency"+"."+"raw", "body", int64(m.Raw)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Latency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Latency) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0Latency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0Snapshot application statistics components items0 snapshot
//
// swagger:model ApplicationStatisticsComponentsItems0Snapshot
type ApplicationStatisticsComponentsItems0Snapshot struct {

	// The amount of space reserved by the system for Snapshot copies.
	// Read Only: true
	Reserve int64 `json:"reserve,omitempty" yaml:"reserve,omitempty"`

	// The amount of spacing currently in use by the system to store Snapshot copies.
	// Read Only: true
	Used int64 `json:"used,omitempty" yaml:"used,omitempty"`
}

// Validate validates this application statistics components items0 snapshot
func (m *ApplicationStatisticsComponentsItems0Snapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics components items0 snapshot based on the context it is used
func (m *ApplicationStatisticsComponentsItems0Snapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReserve(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0Snapshot) contextValidateReserve(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"reserve", "body", int64(m.Reserve)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Snapshot) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Snapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Snapshot) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0Snapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0Space application statistics components items0 space
//
// swagger:model ApplicationStatisticsComponentsItems0Space
type ApplicationStatisticsComponentsItems0Space struct {

	// The available amount of space left in the application component. Note that this field has limited meaning for SAN applications. Space may be considered used from ONTAP's perspective while the host filesystem still considers it available.
	// Read Only: true
	Available int64 `json:"available,omitempty" yaml:"available,omitempty"`

	// The amount of space that would currently be used if no space saving features were enabled. For example, if compression were the only space saving feature enabled, this field would represent the uncompressed amount of space used.
	// Read Only: true
	LogicalUsed int64 `json:"logical_used,omitempty" yaml:"logical_used,omitempty"`

	// The originally requested amount of space that was provisioned for the application component.
	// Read Only: true
	Provisioned int64 `json:"provisioned,omitempty" yaml:"provisioned,omitempty"`

	// The amount of space reserved for system features such as Snapshot copies that has not yet been used.
	// Read Only: true
	ReservedUnused int64 `json:"reserved_unused,omitempty" yaml:"reserved_unused,omitempty"`

	// The amount of space saved by all enabled space saving features.
	// Read Only: true
	Savings int64 `json:"savings,omitempty" yaml:"savings,omitempty"`

	// The amount of space that is currently being used by the application component. Note that this includes any space reserved by the system for features such as Snapshot copies.
	// Read Only: true
	Used int64 `json:"used,omitempty" yaml:"used,omitempty"`

	// The amount of space that is currently being used, excluding any space that is reserved by the system for features such as Snapshot copies.
	// Read Only: true
	UsedExcludingReserves int64 `json:"used_excluding_reserves,omitempty" yaml:"used_excluding_reserves,omitempty"`

	// The percentage of the originally provisioned space that is currently being used by the application component.
	// Read Only: true
	UsedPercent int64 `json:"used_percent,omitempty" yaml:"used_percent,omitempty"`
}

// Validate validates this application statistics components items0 space
func (m *ApplicationStatisticsComponentsItems0Space) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics components items0 space based on the context it is used
func (m *ApplicationStatisticsComponentsItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioned(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReservedUnused(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSavings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedExcludingReserves(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateLogicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_used", "body", int64(m.LogicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateProvisioned(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"provisioned", "body", int64(m.Provisioned)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateReservedUnused(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"reserved_unused", "body", int64(m.ReservedUnused)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateSavings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"savings", "body", int64(m.Savings)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateUsedExcludingReserves(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used_excluding_reserves", "body", int64(m.UsedExcludingReserves)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0Space) contextValidateUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used_percent", "body", int64(m.UsedPercent)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0Space) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsComponentsItems0StorageService application statistics components items0 storage service
//
// swagger:model ApplicationStatisticsComponentsItems0StorageService
type ApplicationStatisticsComponentsItems0StorageService struct {

	// The storage service name. AFF systems support the extreme storage service. All other systems only support value.
	// Read Only: true
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The storage service UUID.
	// Read Only: true
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this application statistics components items0 storage service
func (m *ApplicationStatisticsComponentsItems0StorageService) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics components items0 storage service based on the context it is used
func (m *ApplicationStatisticsComponentsItems0StorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsComponentsItems0StorageService) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_service"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsComponentsItems0StorageService) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_service"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0StorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsComponentsItems0StorageService) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsComponentsItems0StorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsIops application statistics iops
//
// swagger:model ApplicationStatisticsIops
type ApplicationStatisticsIops struct {

	// The number of IOPS per terabyte of logical space currently being used by the application.
	// Read Only: true
	PerTb int64 `json:"per_tb,omitempty" yaml:"per_tb,omitempty"`

	// The total number of IOPS being used by the application.
	// Read Only: true
	Total int64 `json:"total,omitempty" yaml:"total,omitempty"`
}

// Validate validates this application statistics iops
func (m *ApplicationStatisticsIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics iops based on the context it is used
func (m *ApplicationStatisticsIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePerTb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsIops) contextValidatePerTb(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"iops"+"."+"per_tb", "body", int64(m.PerTb)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsIops) contextValidateTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"iops"+"."+"total", "body", int64(m.Total)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsIops) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsLatency application statistics latency
//
// swagger:model ApplicationStatisticsLatency
type ApplicationStatisticsLatency struct {

	// The cumulative average response time in microseconds for this application.
	// Read Only: true
	Average int64 `json:"average,omitempty" yaml:"average,omitempty"`

	// The cumulative response time in microseconds for this application.
	// Read Only: true
	Raw int64 `json:"raw,omitempty" yaml:"raw,omitempty"`
}

// Validate validates this application statistics latency
func (m *ApplicationStatisticsLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics latency based on the context it is used
func (m *ApplicationStatisticsLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAverage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsLatency) contextValidateAverage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"latency"+"."+"average", "body", int64(m.Average)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsLatency) contextValidateRaw(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"latency"+"."+"raw", "body", int64(m.Raw)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsLatency) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsSnapshot application statistics snapshot
//
// swagger:model ApplicationStatisticsSnapshot
type ApplicationStatisticsSnapshot struct {

	// The amount of space reserved by the system for Snapshot copies.
	// Read Only: true
	Reserve int64 `json:"reserve,omitempty" yaml:"reserve,omitempty"`

	// The amount of spacing currently in use by the system to store Snapshot copies.
	// Read Only: true
	Used int64 `json:"used,omitempty" yaml:"used,omitempty"`
}

// Validate validates this application statistics snapshot
func (m *ApplicationStatisticsSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics snapshot based on the context it is used
func (m *ApplicationStatisticsSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReserve(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsSnapshot) contextValidateReserve(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"snapshot"+"."+"reserve", "body", int64(m.Reserve)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSnapshot) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"snapshot"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsSnapshot) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationStatisticsSpace application statistics space
//
// swagger:model ApplicationStatisticsSpace
type ApplicationStatisticsSpace struct {

	// The available amount of space left in the application. Note that this field has limited meaning for SAN applications. Space may be considered used from ONTAP's perspective while the host filesystem still considers it available.
	// Read Only: true
	Available int64 `json:"available,omitempty" yaml:"available,omitempty"`

	// The amount of space that would currently be used if no space saving features were enabled. For example, if compression were the only space saving feature enabled, this field would represent the uncompressed amount of space used.
	// Read Only: true
	LogicalUsed int64 `json:"logical_used,omitempty" yaml:"logical_used,omitempty"`

	// The originally requested amount of space that was provisioned for the application.
	// Read Only: true
	Provisioned int64 `json:"provisioned,omitempty" yaml:"provisioned,omitempty"`

	// The amount of space reserved for system features such as Snapshot copies that has not yet been used.
	// Read Only: true
	ReservedUnused int64 `json:"reserved_unused,omitempty" yaml:"reserved_unused,omitempty"`

	// The amount of space saved by all enabled space saving features.
	// Read Only: true
	Savings int64 `json:"savings,omitempty" yaml:"savings,omitempty"`

	// The amount of space that is currently being used by the application. Note that this includes any space reserved by the system for features such as Snapshot copies.
	// Read Only: true
	Used int64 `json:"used,omitempty" yaml:"used,omitempty"`

	// The amount of space that is currently being used, excluding any space that is reserved by the system for features such as Snapshot copies.
	// Read Only: true
	UsedExcludingReserves int64 `json:"used_excluding_reserves,omitempty" yaml:"used_excluding_reserves,omitempty"`

	// The percentage of the originally provisioned space that is currently being used by the application.
	// Read Only: true
	UsedPercent int64 `json:"used_percent,omitempty" yaml:"used_percent,omitempty"`
}

// Validate validates this application statistics space
func (m *ApplicationStatisticsSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application statistics space based on the context it is used
func (m *ApplicationStatisticsSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioned(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReservedUnused(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSavings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedExcludingReserves(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateLogicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"logical_used", "body", int64(m.LogicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateProvisioned(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"provisioned", "body", int64(m.Provisioned)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateReservedUnused(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"reserved_unused", "body", int64(m.ReservedUnused)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateSavings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"savings", "body", int64(m.Savings)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateUsedExcludingReserves(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"used_excluding_reserves", "body", int64(m.UsedExcludingReserves)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationStatisticsSpace) contextValidateUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"space"+"."+"used_percent", "body", int64(m.UsedPercent)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationStatisticsSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationStatisticsSpace) UnmarshalBinary(b []byte) error {
	var res ApplicationStatisticsSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationSvm application svm
//
// swagger:model ApplicationSvm
type ApplicationSvm struct {

	// SVM Name. Either the SVM name or UUID must be provided to create an application.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// SVM UUID. Either the SVM name or UUID must be provided to create an application.
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this application svm
func (m *ApplicationSvm) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this application svm based on context it is used
func (m *ApplicationSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationSvm) UnmarshalBinary(b []byte) error {
	var res ApplicationSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationTemplate application template
//
// swagger:model ApplicationTemplate
type ApplicationTemplate struct {

	// links
	Links *SelfLink `json:"_links,omitempty" yaml:"_links,omitempty"`

	// The name of the template that was used to provision this application.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The protocol access of the template that was used to provision this application.
	// Read Only: true
	// Enum: ["nas","nvme","s3","san"]
	Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty"`

	// The version of the template that was used to provision this application. The template version changes only if the layout of the application changes over time. For example, redo logs in Oracle RAC templates were updated and provisioned differently in DATA ONTAP 9.3.0 compared to prior releases, so the version number was increased. If layouts change in the future, the changes will be documented along with the corresponding version numbers.
	// Read Only: true
	Version int64 `json:"version,omitempty" yaml:"version,omitempty"`
}

// Validate validates this application template
func (m *ApplicationTemplate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationTemplate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("template" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("template" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var applicationTemplateTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["nas","nvme","s3","san"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTemplateTypeProtocolPropEnum = append(applicationTemplateTypeProtocolPropEnum, v)
	}
}

const (

	// ApplicationTemplateProtocolNas captures enum value "nas"
	ApplicationTemplateProtocolNas string = "nas"

	// ApplicationTemplateProtocolNvme captures enum value "nvme"
	ApplicationTemplateProtocolNvme string = "nvme"

	// ApplicationTemplateProtocolS3 captures enum value "s3"
	ApplicationTemplateProtocolS3 string = "s3"

	// ApplicationTemplateProtocolSan captures enum value "san"
	ApplicationTemplateProtocolSan string = "san"
)

// prop value enum
func (m *ApplicationTemplate) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTemplateTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationTemplate) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("template"+"."+"protocol", "body", m.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application template based on the context it is used
func (m *ApplicationTemplate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationTemplate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("template" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("template" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationTemplate) contextValidateProtocol(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "template"+"."+"protocol", "body", string(m.Protocol)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationTemplate) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "template"+"."+"version", "body", int64(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationTemplate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationTemplate) UnmarshalBinary(b []byte) error {
	var res ApplicationTemplate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
