// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ZappNvme An NVME application.
//
// swagger:model zapp_nvme
type ZappNvme struct {

	// components
	// Required: true
	// Max Items: 10
	// Min Items: 1
	Components []*ZappNvmeComponentsItems0 `json:"components" yaml:"components"`

	// The name of the host OS running the application.
	// Enum: ["aix","linux","vmware","windows"]
	OsType string `json:"os_type,omitempty" yaml:"os_type,omitempty"`

	// rpo
	Rpo *ZappNvmeRpo `json:"rpo,omitempty" yaml:"rpo,omitempty"`
}

// Validate validates this zapp nvme
func (m *ZappNvme) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRpo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvme) validateComponents(formats strfmt.Registry) error {

	if err := validate.Required("components", "body", m.Components); err != nil {
		return err
	}

	iComponentsSize := int64(len(m.Components))

	if err := validate.MinItems("components", "body", iComponentsSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("components", "body", iComponentsSize, 10); err != nil {
		return err
	}

	for i := 0; i < len(m.Components); i++ {
		if swag.IsZero(m.Components[i]) { // not required
			continue
		}

		if m.Components[i] != nil {
			if err := m.Components[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var zappNvmeTypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","linux","vmware","windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zappNvmeTypeOsTypePropEnum = append(zappNvmeTypeOsTypePropEnum, v)
	}
}

const (

	// ZappNvmeOsTypeAix captures enum value "aix"
	ZappNvmeOsTypeAix string = "aix"

	// ZappNvmeOsTypeLinux captures enum value "linux"
	ZappNvmeOsTypeLinux string = "linux"

	// ZappNvmeOsTypeVmware captures enum value "vmware"
	ZappNvmeOsTypeVmware string = "vmware"

	// ZappNvmeOsTypeWindows captures enum value "windows"
	ZappNvmeOsTypeWindows string = "windows"
)

// prop value enum
func (m *ZappNvme) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zappNvmeTypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ZappNvme) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ZappNvme) validateRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.Rpo) { // not required
		return nil
	}

	if m.Rpo != nil {
		if err := m.Rpo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zapp nvme based on the context it is used
func (m *ZappNvme) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRpo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvme) contextValidateComponents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Components); i++ {

		if m.Components[i] != nil {

			if swag.IsZero(m.Components[i]) { // not required
				return nil
			}

			if err := m.Components[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZappNvme) contextValidateRpo(ctx context.Context, formats strfmt.Registry) error {

	if m.Rpo != nil {

		if swag.IsZero(m.Rpo) { // not required
			return nil
		}

		if err := m.Rpo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvme) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvme) UnmarshalBinary(b []byte) error {
	var res ZappNvme
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeComponentsItems0 zapp nvme components items0
//
// swagger:model ZappNvmeComponentsItems0
type ZappNvmeComponentsItems0 struct {

	// The name of the application component.
	// Required: true
	// Max Length: 203
	// Min Length: 1
	Name *string `json:"name" yaml:"name"`

	// The number of namespaces supported per request, with a total limit of 1024 per volume.
	// Maximum: 32
	// Minimum: 1
	NamespaceCount int64 `json:"namespace_count,omitempty" yaml:"namespace_count,omitempty"`

	// The name of the host OS running the application.
	// Enum: ["aix","linux","vmware","windows"]
	OsType string `json:"os_type,omitempty" yaml:"os_type,omitempty"`

	// performance
	Performance *ZappNvmeComponentsItems0Performance `json:"performance,omitempty" yaml:"performance,omitempty"`

	// qos
	Qos *ZappNvmeComponentsItems0Qos `json:"qos,omitempty" yaml:"qos,omitempty"`

	// subsystem
	Subsystem *ZappNvmeComponentsSubsystem `json:"subsystem,omitempty" yaml:"subsystem,omitempty"`

	// tiering
	Tiering *ZappNvmeComponentsTiering `json:"tiering,omitempty" yaml:"tiering,omitempty"`

	// The total size of the component, spread across member namespaces. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	TotalSize int64 `json:"total_size,omitempty" yaml:"total_size,omitempty"`
}

// Validate validates this zapp nvme components items0
func (m *ZappNvmeComponentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespaceCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerformance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubsystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) validateNamespaceCount(formats strfmt.Registry) error {
	if swag.IsZero(m.NamespaceCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("namespace_count", "body", m.NamespaceCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("namespace_count", "body", m.NamespaceCount, 32, false); err != nil {
		return err
	}

	return nil
}

var zappNvmeComponentsItems0TypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","linux","vmware","windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zappNvmeComponentsItems0TypeOsTypePropEnum = append(zappNvmeComponentsItems0TypeOsTypePropEnum, v)
	}
}

const (

	// ZappNvmeComponentsItems0OsTypeAix captures enum value "aix"
	ZappNvmeComponentsItems0OsTypeAix string = "aix"

	// ZappNvmeComponentsItems0OsTypeLinux captures enum value "linux"
	ZappNvmeComponentsItems0OsTypeLinux string = "linux"

	// ZappNvmeComponentsItems0OsTypeVmware captures enum value "vmware"
	ZappNvmeComponentsItems0OsTypeVmware string = "vmware"

	// ZappNvmeComponentsItems0OsTypeWindows captures enum value "windows"
	ZappNvmeComponentsItems0OsTypeWindows string = "windows"
)

// prop value enum
func (m *ZappNvmeComponentsItems0) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zappNvmeComponentsItems0TypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ZappNvmeComponentsItems0) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) validatePerformance(formats strfmt.Registry) error {
	if swag.IsZero(m.Performance) { // not required
		return nil
	}

	if m.Performance != nil {
		if err := m.Performance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("performance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("performance")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) validateSubsystem(formats strfmt.Registry) error {
	if swag.IsZero(m.Subsystem) { // not required
		return nil
	}

	if m.Subsystem != nil {
		if err := m.Subsystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zapp nvme components items0 based on the context it is used
func (m *ZappNvmeComponentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePerformance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubsystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0) contextValidatePerformance(ctx context.Context, formats strfmt.Registry) error {

	if m.Performance != nil {

		if swag.IsZero(m.Performance) { // not required
			return nil
		}

		if err := m.Performance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("performance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("performance")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {

		if swag.IsZero(m.Qos) { // not required
			return nil
		}

		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) contextValidateSubsystem(ctx context.Context, formats strfmt.Registry) error {

	if m.Subsystem != nil {

		if swag.IsZero(m.Subsystem) { // not required
			return nil
		}

		if err := m.Subsystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeComponentsItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {

		if swag.IsZero(m.Tiering) { // not required
			return nil
		}

		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0) UnmarshalBinary(b []byte) error {
	var res ZappNvmeComponentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeComponentsItems0Performance zapp nvme components items0 performance
//
// swagger:model ZappNvmeComponentsItems0Performance
type ZappNvmeComponentsItems0Performance struct {

	// storage service
	StorageService *ZappNvmeComponentsItems0PerformanceStorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`
}

// Validate validates this zapp nvme components items0 performance
func (m *ZappNvmeComponentsItems0Performance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0Performance) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("performance" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("performance" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zapp nvme components items0 performance based on the context it is used
func (m *ZappNvmeComponentsItems0Performance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0Performance) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("performance" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("performance" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0Performance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0Performance) UnmarshalBinary(b []byte) error {
	var res ZappNvmeComponentsItems0Performance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeComponentsItems0PerformanceStorageService zapp nvme components items0 performance storage service
//
// swagger:model ZappNvmeComponentsItems0PerformanceStorageService
type ZappNvmeComponentsItems0PerformanceStorageService struct {

	// The storage service of the application component.
	// Enum: ["extreme","performance","value"]
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this zapp nvme components items0 performance storage service
func (m *ZappNvmeComponentsItems0PerformanceStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var zappNvmeComponentsItems0PerformanceStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zappNvmeComponentsItems0PerformanceStorageServiceTypeNamePropEnum = append(zappNvmeComponentsItems0PerformanceStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// ZappNvmeComponentsItems0PerformanceStorageServiceNameExtreme captures enum value "extreme"
	ZappNvmeComponentsItems0PerformanceStorageServiceNameExtreme string = "extreme"

	// ZappNvmeComponentsItems0PerformanceStorageServiceNamePerformance captures enum value "performance"
	ZappNvmeComponentsItems0PerformanceStorageServiceNamePerformance string = "performance"

	// ZappNvmeComponentsItems0PerformanceStorageServiceNameValue captures enum value "value"
	ZappNvmeComponentsItems0PerformanceStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ZappNvmeComponentsItems0PerformanceStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zappNvmeComponentsItems0PerformanceStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ZappNvmeComponentsItems0PerformanceStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("performance"+"."+"storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this zapp nvme components items0 performance storage service based on context it is used
func (m *ZappNvmeComponentsItems0PerformanceStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0PerformanceStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0PerformanceStorageService) UnmarshalBinary(b []byte) error {
	var res ZappNvmeComponentsItems0PerformanceStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeComponentsItems0Qos zapp nvme components items0 qos
//
// swagger:model ZappNvmeComponentsItems0Qos
type ZappNvmeComponentsItems0Qos struct {

	// policy
	Policy *ZappNvmeComponentsItems0QosPolicy `json:"policy,omitempty" yaml:"policy,omitempty"`
}

// Validate validates this zapp nvme components items0 qos
func (m *ZappNvmeComponentsItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zapp nvme components items0 qos based on the context it is used
func (m *ZappNvmeComponentsItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeComponentsItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {

		if swag.IsZero(m.Policy) { // not required
			return nil
		}

		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0Qos) UnmarshalBinary(b []byte) error {
	var res ZappNvmeComponentsItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeComponentsItems0QosPolicy zapp nvme components items0 qos policy
//
// swagger:model ZappNvmeComponentsItems0QosPolicy
type ZappNvmeComponentsItems0QosPolicy struct {

	// The name of an existing QoS policy.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The UUID of an existing QoS policy. Usage: &lt;UUID&gt;
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this zapp nvme components items0 qos policy
func (m *ZappNvmeComponentsItems0QosPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this zapp nvme components items0 qos policy based on context it is used
func (m *ZappNvmeComponentsItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeComponentsItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ZappNvmeComponentsItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeRpo zapp nvme rpo
//
// swagger:model ZappNvmeRpo
type ZappNvmeRpo struct {

	// local
	Local *ZappNvmeRpoLocal `json:"local,omitempty" yaml:"local,omitempty"`

	// remote
	Remote *ZappNvmeRpoRemote `json:"remote,omitempty" yaml:"remote,omitempty"`
}

// Validate validates this zapp nvme rpo
func (m *ZappNvmeRpo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeRpo) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeRpo) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zapp nvme rpo based on the context it is used
func (m *ZappNvmeRpo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZappNvmeRpo) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {

		if swag.IsZero(m.Local) { // not required
			return nil
		}

		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "local")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ZappNvmeRpo) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {

		if swag.IsZero(m.Remote) { // not required
			return nil
		}

		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rpo" + "." + "remote")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rpo" + "." + "remote")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeRpo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeRpo) UnmarshalBinary(b []byte) error {
	var res ZappNvmeRpo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeRpoLocal zapp nvme rpo local
//
// swagger:model ZappNvmeRpoLocal
type ZappNvmeRpoLocal struct {

	// The local RPO of the application.
	// Enum: ["hourly","none"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The Snapshot copy policy to apply to each volume in the smart container. This property is only supported for smart containers. Usage: &lt;snapshot policy&gt;
	Policy string `json:"policy,omitempty" yaml:"policy,omitempty"`
}

// Validate validates this zapp nvme rpo local
func (m *ZappNvmeRpoLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var zappNvmeRpoLocalTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zappNvmeRpoLocalTypeNamePropEnum = append(zappNvmeRpoLocalTypeNamePropEnum, v)
	}
}

const (

	// ZappNvmeRpoLocalNameHourly captures enum value "hourly"
	ZappNvmeRpoLocalNameHourly string = "hourly"

	// ZappNvmeRpoLocalNameNone captures enum value "none"
	ZappNvmeRpoLocalNameNone string = "none"
)

// prop value enum
func (m *ZappNvmeRpoLocal) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zappNvmeRpoLocalTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ZappNvmeRpoLocal) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"local"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this zapp nvme rpo local based on context it is used
func (m *ZappNvmeRpoLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeRpoLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeRpoLocal) UnmarshalBinary(b []byte) error {
	var res ZappNvmeRpoLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ZappNvmeRpoRemote zapp nvme rpo remote
//
// swagger:model ZappNvmeRpoRemote
type ZappNvmeRpoRemote struct {

	// The remote RPO of the application.
	// Enum: ["none","zero"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this zapp nvme rpo remote
func (m *ZappNvmeRpoRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var zappNvmeRpoRemoteTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zappNvmeRpoRemoteTypeNamePropEnum = append(zappNvmeRpoRemoteTypeNamePropEnum, v)
	}
}

const (

	// ZappNvmeRpoRemoteNameNone captures enum value "none"
	ZappNvmeRpoRemoteNameNone string = "none"

	// ZappNvmeRpoRemoteNameZero captures enum value "zero"
	ZappNvmeRpoRemoteNameZero string = "zero"
)

// prop value enum
func (m *ZappNvmeRpoRemote) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zappNvmeRpoRemoteTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ZappNvmeRpoRemote) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("rpo"+"."+"remote"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this zapp nvme rpo remote based on context it is used
func (m *ZappNvmeRpoRemote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ZappNvmeRpoRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZappNvmeRpoRemote) UnmarshalBinary(b []byte) error {
	var res ZappNvmeRpoRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
