// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SQLOnSmb Microsoft SQL using SMB.
//
// swagger:model sql_on_smb
type SQLOnSmb struct {

	// access
	// Required: true
	Access *SQLOnSmbAccess `json:"access" yaml:"access"`

	// db
	// Required: true
	Db *SQLOnSmbDb `json:"db" yaml:"db"`

	// log
	// Required: true
	Log *SQLOnSmbLog `json:"log" yaml:"log"`

	// protection type
	ProtectionType *SQLOnSmbProtectionType `json:"protection_type,omitempty" yaml:"protection_type,omitempty"`

	// The number of server cores for the DB.
	ServerCoresCount *int64 `json:"server_cores_count,omitempty" yaml:"server_cores_count,omitempty"`

	// temp db
	TempDb *SQLOnSmbTempDb `json:"temp_db,omitempty" yaml:"temp_db,omitempty"`
}

// Validate validates this sql on smb
func (m *SQLOnSmb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTempDb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmb) validateAccess(formats strfmt.Registry) error {

	if err := validate.Required("access", "body", m.Access); err != nil {
		return err
	}

	if m.Access != nil {
		if err := m.Access.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("access")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) validateDb(formats strfmt.Registry) error {

	if err := validate.Required("db", "body", m.Db); err != nil {
		return err
	}

	if m.Db != nil {
		if err := m.Db.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("db")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("db")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) validateLog(formats strfmt.Registry) error {

	if err := validate.Required("log", "body", m.Log); err != nil {
		return err
	}

	if m.Log != nil {
		if err := m.Log.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) validateProtectionType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	if m.ProtectionType != nil {
		if err := m.ProtectionType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) validateTempDb(formats strfmt.Registry) error {
	if swag.IsZero(m.TempDb) { // not required
		return nil
	}

	if m.TempDb != nil {
		if err := m.TempDb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("temp_db")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("temp_db")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this sql on smb based on the context it is used
func (m *SQLOnSmb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTempDb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmb) contextValidateAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.Access != nil {

		if err := m.Access.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("access")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) contextValidateDb(ctx context.Context, formats strfmt.Registry) error {

	if m.Db != nil {

		if err := m.Db.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("db")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("db")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) contextValidateLog(ctx context.Context, formats strfmt.Registry) error {

	if m.Log != nil {

		if err := m.Log.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) contextValidateProtectionType(ctx context.Context, formats strfmt.Registry) error {

	if m.ProtectionType != nil {

		if swag.IsZero(m.ProtectionType) { // not required
			return nil
		}

		if err := m.ProtectionType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

func (m *SQLOnSmb) contextValidateTempDb(ctx context.Context, formats strfmt.Registry) error {

	if m.TempDb != nil {

		if swag.IsZero(m.TempDb) { // not required
			return nil
		}

		if err := m.TempDb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("temp_db")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("temp_db")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmb) UnmarshalBinary(b []byte) error {
	var res SQLOnSmb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbAccess SQL on smb access
//
// swagger:model SQLOnSmbAccess
type SQLOnSmbAccess struct {

	// SQL installer admin user name.
	// Max Length: 256
	// Min Length: 1
	Installer string `json:"installer,omitempty" yaml:"installer,omitempty"`

	// SQL service account user name.
	// Required: true
	// Max Length: 256
	// Min Length: 1
	ServiceAccount *string `json:"service_account" yaml:"service_account"`
}

// Validate validates this SQL on smb access
func (m *SQLOnSmbAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInstaller(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAccount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbAccess) validateInstaller(formats strfmt.Registry) error {
	if swag.IsZero(m.Installer) { // not required
		return nil
	}

	if err := validate.MinLength("access"+"."+"installer", "body", m.Installer, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("access"+"."+"installer", "body", m.Installer, 256); err != nil {
		return err
	}

	return nil
}

func (m *SQLOnSmbAccess) validateServiceAccount(formats strfmt.Registry) error {

	if err := validate.Required("access"+"."+"service_account", "body", m.ServiceAccount); err != nil {
		return err
	}

	if err := validate.MinLength("access"+"."+"service_account", "body", *m.ServiceAccount, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("access"+"."+"service_account", "body", *m.ServiceAccount, 256); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SQL on smb access based on context it is used
func (m *SQLOnSmbAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbAccess) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbAccess) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbDb SQL on smb db
//
// swagger:model SQLOnSmbDb
type SQLOnSmbDb struct {

	// The size of the DB. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	// Required: true
	Size *int64 `json:"size" yaml:"size"`

	// storage service
	StorageService *SQLOnSmbDbStorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`
}

// Validate validates this SQL on smb db
func (m *SQLOnSmbDb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbDb) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("db"+"."+"size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

func (m *SQLOnSmbDb) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("db" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("db" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this SQL on smb db based on the context it is used
func (m *SQLOnSmbDb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbDb) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("db" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("db" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbDb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbDb) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbDb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbDbStorageService SQL on smb db storage service
//
// swagger:model SQLOnSmbDbStorageService
type SQLOnSmbDbStorageService struct {

	// The storage service of the DB.
	// Enum: ["extreme","performance","value"]
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this SQL on smb db storage service
func (m *SQLOnSmbDbStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var sqlOnSmbDbStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlOnSmbDbStorageServiceTypeNamePropEnum = append(sqlOnSmbDbStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// SQLOnSmbDbStorageServiceNameExtreme captures enum value "extreme"
	SQLOnSmbDbStorageServiceNameExtreme string = "extreme"

	// SQLOnSmbDbStorageServiceNamePerformance captures enum value "performance"
	SQLOnSmbDbStorageServiceNamePerformance string = "performance"

	// SQLOnSmbDbStorageServiceNameValue captures enum value "value"
	SQLOnSmbDbStorageServiceNameValue string = "value"
)

// prop value enum
func (m *SQLOnSmbDbStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlOnSmbDbStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLOnSmbDbStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("db"+"."+"storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SQL on smb db storage service based on context it is used
func (m *SQLOnSmbDbStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbDbStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbDbStorageService) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbDbStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbLog SQL on smb log
//
// swagger:model SQLOnSmbLog
type SQLOnSmbLog struct {

	// The size of the log DB. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	// Required: true
	Size *int64 `json:"size" yaml:"size"`

	// storage service
	StorageService *SQLOnSmbLogStorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`
}

// Validate validates this SQL on smb log
func (m *SQLOnSmbLog) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbLog) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("log"+"."+"size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

func (m *SQLOnSmbLog) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this SQL on smb log based on the context it is used
func (m *SQLOnSmbLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbLog) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbLog) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbLogStorageService SQL on smb log storage service
//
// swagger:model SQLOnSmbLogStorageService
type SQLOnSmbLogStorageService struct {

	// The storage service of the log DB.
	// Enum: ["extreme","performance","value"]
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this SQL on smb log storage service
func (m *SQLOnSmbLogStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var sqlOnSmbLogStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlOnSmbLogStorageServiceTypeNamePropEnum = append(sqlOnSmbLogStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// SQLOnSmbLogStorageServiceNameExtreme captures enum value "extreme"
	SQLOnSmbLogStorageServiceNameExtreme string = "extreme"

	// SQLOnSmbLogStorageServiceNamePerformance captures enum value "performance"
	SQLOnSmbLogStorageServiceNamePerformance string = "performance"

	// SQLOnSmbLogStorageServiceNameValue captures enum value "value"
	SQLOnSmbLogStorageServiceNameValue string = "value"
)

// prop value enum
func (m *SQLOnSmbLogStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlOnSmbLogStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLOnSmbLogStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("log"+"."+"storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SQL on smb log storage service based on context it is used
func (m *SQLOnSmbLogStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbLogStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbLogStorageService) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbLogStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbProtectionType SQL on smb protection type
//
// swagger:model SQLOnSmbProtectionType
type SQLOnSmbProtectionType struct {

	// The local RPO of the application.
	// Enum: ["hourly","none"]
	LocalRpo string `json:"local_rpo,omitempty" yaml:"local_rpo,omitempty"`

	// The remote RPO of the application.
	// Enum: ["none","zero"]
	RemoteRpo string `json:"remote_rpo,omitempty" yaml:"remote_rpo,omitempty"`
}

// Validate validates this SQL on smb protection type
func (m *SQLOnSmbProtectionType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocalRpo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteRpo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var sqlOnSmbProtectionTypeTypeLocalRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlOnSmbProtectionTypeTypeLocalRpoPropEnum = append(sqlOnSmbProtectionTypeTypeLocalRpoPropEnum, v)
	}
}

const (

	// SQLOnSmbProtectionTypeLocalRpoHourly captures enum value "hourly"
	SQLOnSmbProtectionTypeLocalRpoHourly string = "hourly"

	// SQLOnSmbProtectionTypeLocalRpoNone captures enum value "none"
	SQLOnSmbProtectionTypeLocalRpoNone string = "none"
)

// prop value enum
func (m *SQLOnSmbProtectionType) validateLocalRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlOnSmbProtectionTypeTypeLocalRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLOnSmbProtectionType) validateLocalRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocalRpoEnum("protection_type"+"."+"local_rpo", "body", m.LocalRpo); err != nil {
		return err
	}

	return nil
}

var sqlOnSmbProtectionTypeTypeRemoteRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlOnSmbProtectionTypeTypeRemoteRpoPropEnum = append(sqlOnSmbProtectionTypeTypeRemoteRpoPropEnum, v)
	}
}

const (

	// SQLOnSmbProtectionTypeRemoteRpoNone captures enum value "none"
	SQLOnSmbProtectionTypeRemoteRpoNone string = "none"

	// SQLOnSmbProtectionTypeRemoteRpoZero captures enum value "zero"
	SQLOnSmbProtectionTypeRemoteRpoZero string = "zero"
)

// prop value enum
func (m *SQLOnSmbProtectionType) validateRemoteRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlOnSmbProtectionTypeTypeRemoteRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLOnSmbProtectionType) validateRemoteRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemoteRpoEnum("protection_type"+"."+"remote_rpo", "body", m.RemoteRpo); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SQL on smb protection type based on context it is used
func (m *SQLOnSmbProtectionType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbProtectionType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbProtectionType) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbProtectionType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbTempDb SQL on smb temp db
//
// swagger:model SQLOnSmbTempDb
type SQLOnSmbTempDb struct {

	// The size of the temp DB. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	Size int64 `json:"size,omitempty" yaml:"size,omitempty"`

	// storage service
	StorageService *SQLOnSmbTempDbStorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`
}

// Validate validates this SQL on smb temp db
func (m *SQLOnSmbTempDb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbTempDb) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("temp_db" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("temp_db" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this SQL on smb temp db based on the context it is used
func (m *SQLOnSmbTempDb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLOnSmbTempDb) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("temp_db" + "." + "storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("temp_db" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbTempDb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbTempDb) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbTempDb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SQLOnSmbTempDbStorageService SQL on smb temp db storage service
//
// swagger:model SQLOnSmbTempDbStorageService
type SQLOnSmbTempDbStorageService struct {

	// The storage service of the temp DB.
	// Enum: ["extreme","performance","value"]
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this SQL on smb temp db storage service
func (m *SQLOnSmbTempDbStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var sqlOnSmbTempDbStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlOnSmbTempDbStorageServiceTypeNamePropEnum = append(sqlOnSmbTempDbStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// SQLOnSmbTempDbStorageServiceNameExtreme captures enum value "extreme"
	SQLOnSmbTempDbStorageServiceNameExtreme string = "extreme"

	// SQLOnSmbTempDbStorageServiceNamePerformance captures enum value "performance"
	SQLOnSmbTempDbStorageServiceNamePerformance string = "performance"

	// SQLOnSmbTempDbStorageServiceNameValue captures enum value "value"
	SQLOnSmbTempDbStorageServiceNameValue string = "value"
)

// prop value enum
func (m *SQLOnSmbTempDbStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlOnSmbTempDbStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLOnSmbTempDbStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("temp_db"+"."+"storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SQL on smb temp db storage service based on context it is used
func (m *SQLOnSmbTempDbStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SQLOnSmbTempDbStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLOnSmbTempDbStorageService) UnmarshalBinary(b []byte) error {
	var res SQLOnSmbTempDbStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
