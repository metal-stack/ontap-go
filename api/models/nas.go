// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Nas A generic NAS application.
//
// swagger:model nas
type Nas struct {

	// application components
	// Required: true
	// Max Items: 10
	// Min Items: 1
	ApplicationComponents []*NasApplicationComponentsItems0 `json:"application_components" yaml:"application_components"`

	// The list of CIFS access controls. You must provide either 'user_or_group' or 'access' to enable CIFS access.
	CifsAccess []*AppCifsAccess `json:"cifs_access" yaml:"cifs_access"`

	// The name of the CIFS share. Usage: &lt;Share&gt;
	CifsShareName string `json:"cifs_share_name,omitempty" yaml:"cifs_share_name,omitempty"`

	// exclude aggregates
	ExcludeAggregates []*NasExcludeAggregatesItems0 `json:"exclude_aggregates" yaml:"exclude_aggregates"`

	// The list of NFS access controls. You must provide either 'host' or 'access' to enable NFS access.
	NfsAccess []*AppNfsAccess `json:"nfs_access" yaml:"nfs_access"`

	// protection type
	ProtectionType *NasProtectionType `json:"protection_type,omitempty" yaml:"protection_type,omitempty"`
}

// Validate validates this nas
func (m *Nas) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCifsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Nas) validateApplicationComponents(formats strfmt.Registry) error {

	if err := validate.Required("application_components", "body", m.ApplicationComponents); err != nil {
		return err
	}

	iApplicationComponentsSize := int64(len(m.ApplicationComponents))

	if err := validate.MinItems("application_components", "body", iApplicationComponentsSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("application_components", "body", iApplicationComponentsSize, 10); err != nil {
		return err
	}

	for i := 0; i < len(m.ApplicationComponents); i++ {
		if swag.IsZero(m.ApplicationComponents[i]) { // not required
			continue
		}

		if m.ApplicationComponents[i] != nil {
			if err := m.ApplicationComponents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("application_components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("application_components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateCifsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.CifsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.CifsAccess); i++ {
		if swag.IsZero(m.CifsAccess[i]) { // not required
			continue
		}

		if m.CifsAccess[i] != nil {
			if err := m.CifsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateExcludeAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeAggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeAggregates); i++ {
		if swag.IsZero(m.ExcludeAggregates[i]) { // not required
			continue
		}

		if m.ExcludeAggregates[i] != nil {
			if err := m.ExcludeAggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclude_aggregates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclude_aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateNfsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.NfsAccess); i++ {
		if swag.IsZero(m.NfsAccess[i]) { // not required
			continue
		}

		if m.NfsAccess[i] != nil {
			if err := m.NfsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateProtectionType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	if m.ProtectionType != nil {
		if err := m.ProtectionType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas based on the context it is used
func (m *Nas) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplicationComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCifsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Nas) contextValidateApplicationComponents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ApplicationComponents); i++ {

		if m.ApplicationComponents[i] != nil {

			if swag.IsZero(m.ApplicationComponents[i]) { // not required
				return nil
			}

			if err := m.ApplicationComponents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("application_components" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("application_components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateCifsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CifsAccess); i++ {

		if m.CifsAccess[i] != nil {

			if swag.IsZero(m.CifsAccess[i]) { // not required
				return nil
			}

			if err := m.CifsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateExcludeAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeAggregates); i++ {

		if m.ExcludeAggregates[i] != nil {

			if swag.IsZero(m.ExcludeAggregates[i]) { // not required
				return nil
			}

			if err := m.ExcludeAggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclude_aggregates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclude_aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateNfsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NfsAccess); i++ {

		if m.NfsAccess[i] != nil {

			if swag.IsZero(m.NfsAccess[i]) { // not required
				return nil
			}

			if err := m.NfsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateProtectionType(ctx context.Context, formats strfmt.Registry) error {

	if m.ProtectionType != nil {

		if swag.IsZero(m.ProtectionType) { // not required
			return nil
		}

		if err := m.ProtectionType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Nas) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Nas) UnmarshalBinary(b []byte) error {
	var res Nas
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0 nas application components items0
//
// swagger:model NasApplicationComponentsItems0
type NasApplicationComponentsItems0 struct {

	// export policy
	ExportPolicy *NasApplicationComponentsItems0ExportPolicy `json:"export_policy,omitempty" yaml:"export_policy,omitempty"`

	// flexcache
	Flexcache *NasApplicationComponentsItems0Flexcache `json:"flexcache,omitempty" yaml:"flexcache,omitempty"`

	// The name of the application component.
	// Required: true
	// Max Length: 512
	// Min Length: 1
	Name *string `json:"name" yaml:"name"`

	// qos
	Qos *NasApplicationComponentsItems0Qos `json:"qos,omitempty" yaml:"qos,omitempty"`

	// Denotes a Flexgroup.
	// Enum: [false,true]
	ScaleOut bool `json:"scale_out,omitempty" yaml:"scale_out,omitempty"`

	// The number of shares in the application component.
	// Required: true
	// Maximum: 10
	// Minimum: 1
	ShareCount *int64 `json:"share_count" yaml:"share_count"`

	// snaplock
	Snaplock *NasApplicationComponentsItems0Snaplock `json:"snaplock,omitempty" yaml:"snaplock,omitempty"`

	// Indicates whether Snapshot copy locking is enabled on the volume.
	// Enum: [false,true]
	SnapshotLockingEnabled bool `json:"snapshot_locking_enabled,omitempty" yaml:"snapshot_locking_enabled,omitempty"`

	// storage service
	StorageService *NasApplicationComponentsItems0StorageService `json:"storage_service,omitempty" yaml:"storage_service,omitempty"`

	// tiering
	Tiering *NasApplicationComponentsTiering `json:"tiering,omitempty" yaml:"tiering,omitempty"`

	// The total size of the application component, split across the member shares. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	// Required: true
	TotalSize *int64 `json:"total_size" yaml:"total_size"`
}

// Validate validates this nas application components items0
func (m *NasApplicationComponentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExportPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScaleOut(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShareCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnaplock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotLockingEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0) validateExportPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ExportPolicy) { // not required
		return nil
	}

	if m.ExportPolicy != nil {
		if err := m.ExportPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("export_policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateFlexcache(formats strfmt.Registry) error {
	if swag.IsZero(m.Flexcache) { // not required
		return nil
	}

	if m.Flexcache != nil {
		if err := m.Flexcache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 512); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

var nasApplicationComponentsItems0TypeScaleOutPropEnum []interface{}

func init() {
	var res []bool
	if err := json.Unmarshal([]byte(`[false,true]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0TypeScaleOutPropEnum = append(nasApplicationComponentsItems0TypeScaleOutPropEnum, v)
	}
}

// prop value enum
func (m *NasApplicationComponentsItems0) validateScaleOutEnum(path, location string, value bool) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0TypeScaleOutPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0) validateScaleOut(formats strfmt.Registry) error {
	if swag.IsZero(m.ScaleOut) { // not required
		return nil
	}

	// value enum
	if err := m.validateScaleOutEnum("scale_out", "body", m.ScaleOut); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateShareCount(formats strfmt.Registry) error {

	if err := validate.Required("share_count", "body", m.ShareCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("share_count", "body", *m.ShareCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("share_count", "body", *m.ShareCount, 10, false); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateSnaplock(formats strfmt.Registry) error {
	if swag.IsZero(m.Snaplock) { // not required
		return nil
	}

	if m.Snaplock != nil {
		if err := m.Snaplock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snaplock")
			}
			return err
		}
	}

	return nil
}

var nasApplicationComponentsItems0TypeSnapshotLockingEnabledPropEnum []interface{}

func init() {
	var res []bool
	if err := json.Unmarshal([]byte(`[false,true]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0TypeSnapshotLockingEnabledPropEnum = append(nasApplicationComponentsItems0TypeSnapshotLockingEnabledPropEnum, v)
	}
}

// prop value enum
func (m *NasApplicationComponentsItems0) validateSnapshotLockingEnabledEnum(path, location string, value bool) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0TypeSnapshotLockingEnabledPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0) validateSnapshotLockingEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotLockingEnabled) { // not required
		return nil
	}

	// value enum
	if err := m.validateSnapshotLockingEnabledEnum("snapshot_locking_enabled", "body", m.SnapshotLockingEnabled); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateTotalSize(formats strfmt.Registry) error {

	if err := validate.Required("total_size", "body", m.TotalSize); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nas application components items0 based on the context it is used
func (m *NasApplicationComponentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExportPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnaplock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateExportPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ExportPolicy != nil {

		if swag.IsZero(m.ExportPolicy) { // not required
			return nil
		}

		if err := m.ExportPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("export_policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateFlexcache(ctx context.Context, formats strfmt.Registry) error {

	if m.Flexcache != nil {

		if swag.IsZero(m.Flexcache) { // not required
			return nil
		}

		if err := m.Flexcache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {

		if swag.IsZero(m.Qos) { // not required
			return nil
		}

		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateSnaplock(ctx context.Context, formats strfmt.Registry) error {

	if m.Snaplock != nil {

		if swag.IsZero(m.Snaplock) { // not required
			return nil
		}

		if err := m.Snaplock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snaplock")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {

		if swag.IsZero(m.StorageService) { // not required
			return nil
		}

		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {

		if swag.IsZero(m.Tiering) { // not required
			return nil
		}

		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0ExportPolicy nas application components items0 export policy
//
// swagger:model NasApplicationComponentsItems0ExportPolicy
type NasApplicationComponentsItems0ExportPolicy struct {

	// The ID of an existing NFS export policy.
	ID int64 `json:"id,omitempty" yaml:"id,omitempty"`

	// The name of an existing NFS export policy.
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this nas application components items0 export policy
func (m *NasApplicationComponentsItems0ExportPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nas application components items0 export policy based on context it is used
func (m *NasApplicationComponentsItems0ExportPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0ExportPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0ExportPolicy) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0ExportPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0Flexcache nas application components items0 flexcache
//
// swagger:model NasApplicationComponentsItems0Flexcache
type NasApplicationComponentsItems0Flexcache struct {

	// Dr-cache is a FlexCache volume create time option that has the same flexgroup-msid as that of the origin of a FlexCache volume. By default, dr-cache is disabled. The flexgroup-msid of the FlexCache volume does not need to be same as that of the origin of a FlexCache volume.
	// Enum: [false,true]
	DrCache *bool `json:"dr_cache,omitempty" yaml:"dr_cache,omitempty"`

	// origin
	Origin *NasApplicationComponentsItems0FlexcacheOrigin `json:"origin,omitempty" yaml:"origin,omitempty"`
}

// Validate validates this nas application components items0 flexcache
func (m *NasApplicationComponentsItems0Flexcache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDrCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasApplicationComponentsItems0FlexcacheTypeDrCachePropEnum []interface{}

func init() {
	var res []bool
	if err := json.Unmarshal([]byte(`[false,true]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0FlexcacheTypeDrCachePropEnum = append(nasApplicationComponentsItems0FlexcacheTypeDrCachePropEnum, v)
	}
}

// prop value enum
func (m *NasApplicationComponentsItems0Flexcache) validateDrCacheEnum(path, location string, value bool) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0FlexcacheTypeDrCachePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0Flexcache) validateDrCache(formats strfmt.Registry) error {
	if swag.IsZero(m.DrCache) { // not required
		return nil
	}

	// value enum
	if err := m.validateDrCacheEnum("flexcache"+"."+"dr_cache", "body", *m.DrCache); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0Flexcache) validateOrigin(formats strfmt.Registry) error {
	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	if m.Origin != nil {
		if err := m.Origin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas application components items0 flexcache based on the context it is used
func (m *NasApplicationComponentsItems0Flexcache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Flexcache) contextValidateOrigin(ctx context.Context, formats strfmt.Registry) error {

	if m.Origin != nil {

		if swag.IsZero(m.Origin) { // not required
			return nil
		}

		if err := m.Origin.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Flexcache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Flexcache) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0Flexcache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOrigin nas application components items0 flexcache origin
//
// swagger:model NasApplicationComponentsItems0FlexcacheOrigin
type NasApplicationComponentsItems0FlexcacheOrigin struct {

	// component
	// Required: true
	Component *NasApplicationComponentsItems0FlexcacheOriginComponent `json:"component" yaml:"component"`

	// svm
	// Required: true
	Svm *NasApplicationComponentsItems0FlexcacheOriginSvm `json:"svm" yaml:"svm"`
}

// Validate validates this nas application components items0 flexcache origin
func (m *NasApplicationComponentsItems0FlexcacheOrigin) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) validateComponent(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"component", "body", m.Component); err != nil {
		return err
	}

	if m.Component != nil {
		if err := m.Component.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "component")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin" + "." + "component")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) validateSvm(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"svm", "body", m.Svm); err != nil {
		return err
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas application components items0 flexcache origin based on the context it is used
func (m *NasApplicationComponentsItems0FlexcacheOrigin) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) contextValidateComponent(ctx context.Context, formats strfmt.Registry) error {

	if m.Component != nil {

		if err := m.Component.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "component")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin" + "." + "component")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {

		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOrigin) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOrigin) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOrigin
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOriginComponent nas application components items0 flexcache origin component
//
// swagger:model NasApplicationComponentsItems0FlexcacheOriginComponent
type NasApplicationComponentsItems0FlexcacheOriginComponent struct {

	// Name of the source component.
	// Required: true
	Name *string `json:"name" yaml:"name"`
}

// Validate validates this nas application components items0 flexcache origin component
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) validateName(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"component"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 flexcache origin component based on context it is used
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOriginComponent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOriginSvm nas application components items0 flexcache origin svm
//
// swagger:model NasApplicationComponentsItems0FlexcacheOriginSvm
type NasApplicationComponentsItems0FlexcacheOriginSvm struct {

	// Name of the source SVM.
	// Required: true
	Name *string `json:"name" yaml:"name"`
}

// Validate validates this nas application components items0 flexcache origin svm
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) validateName(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"svm"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 flexcache origin svm based on context it is used
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOriginSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0Qos nas application components items0 qos
//
// swagger:model NasApplicationComponentsItems0Qos
type NasApplicationComponentsItems0Qos struct {

	// policy
	Policy *NasApplicationComponentsItems0QosPolicy `json:"policy,omitempty" yaml:"policy,omitempty"`
}

// Validate validates this nas application components items0 qos
func (m *NasApplicationComponentsItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas application components items0 qos based on the context it is used
func (m *NasApplicationComponentsItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {

		if swag.IsZero(m.Policy) { // not required
			return nil
		}

		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Qos) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0QosPolicy nas application components items0 qos policy
//
// swagger:model NasApplicationComponentsItems0QosPolicy
type NasApplicationComponentsItems0QosPolicy struct {

	// The name of an existing QoS policy.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The UUID of an existing QoS policy. Usage: &lt;UUID&gt;
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this nas application components items0 qos policy
func (m *NasApplicationComponentsItems0QosPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nas application components items0 qos policy based on context it is used
func (m *NasApplicationComponentsItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0Snaplock nas application components items0 snaplock
//
// swagger:model NasApplicationComponentsItems0Snaplock
type NasApplicationComponentsItems0Snaplock struct {

	// Specifies if the volume append mode is enabled or disabled. When it is enabled, all the files created with write permissions on the volume are, by default, WORM appendable files. The user can append the data to a WORM appendable file but cannot modify the existing contents of the file nor delete the file until it expires.
	// Enum: [false,true]
	AppendModeEnabled bool `json:"append_mode_enabled,omitempty" yaml:"append_mode_enabled,omitempty"`

	// Specifies the autocommit period for SnapLock volume. All files which are not modified for a period greater than the autocommit period of the volume are committed to the WORM state. The autocommit period value represents a duration and must be specified in the ISO-8601 duration format. The autocommit period can be in years, months, days, hours, and minutes. A period specified for years, months, and days is represented in the ISO-8601 format as &quot;P&lt;num&gt;Y&quot;, &quot;P&lt;num&gt;M&quot;, &quot;P&lt;num&gt;D&quot; respectively, for example &quot;P10Y&quot; represents a duration of 10 years. A duration in hours and minutes is represented by &quot;PT&lt;num&gt;H&quot; and &quot;PT&lt;num&gt;M&quot; respectively. The period string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example &quot;P1Y10M&quot; is not supported. Apart from the duration specified in the ISO-8601 format, the autocommit field also accepts the string &quot;none&quot;.
	AutocommitPeriod string `json:"autocommit_period,omitempty" yaml:"autocommit_period,omitempty"`

	// retention
	Retention *NasApplicationComponentsItems0SnaplockRetention `json:"retention,omitempty" yaml:"retention,omitempty"`

	// The SnapLock type of the smart container.
	// Enum: ["compliance","enterprise","non_snaplock"]
	SnaplockType string `json:"snaplock_type,omitempty" yaml:"snaplock_type,omitempty"`
}

// Validate validates this nas application components items0 snaplock
func (m *NasApplicationComponentsItems0Snaplock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppendModeEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnaplockType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasApplicationComponentsItems0SnaplockTypeAppendModeEnabledPropEnum []interface{}

func init() {
	var res []bool
	if err := json.Unmarshal([]byte(`[false,true]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0SnaplockTypeAppendModeEnabledPropEnum = append(nasApplicationComponentsItems0SnaplockTypeAppendModeEnabledPropEnum, v)
	}
}

// prop value enum
func (m *NasApplicationComponentsItems0Snaplock) validateAppendModeEnabledEnum(path, location string, value bool) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0SnaplockTypeAppendModeEnabledPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0Snaplock) validateAppendModeEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.AppendModeEnabled) { // not required
		return nil
	}

	// value enum
	if err := m.validateAppendModeEnabledEnum("snaplock"+"."+"append_mode_enabled", "body", m.AppendModeEnabled); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0Snaplock) validateRetention(formats strfmt.Registry) error {
	if swag.IsZero(m.Retention) { // not required
		return nil
	}

	if m.Retention != nil {
		if err := m.Retention.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock" + "." + "retention")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snaplock" + "." + "retention")
			}
			return err
		}
	}

	return nil
}

var nasApplicationComponentsItems0SnaplockTypeSnaplockTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["compliance","enterprise","non_snaplock"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0SnaplockTypeSnaplockTypePropEnum = append(nasApplicationComponentsItems0SnaplockTypeSnaplockTypePropEnum, v)
	}
}

const (

	// NasApplicationComponentsItems0SnaplockSnaplockTypeCompliance captures enum value "compliance"
	NasApplicationComponentsItems0SnaplockSnaplockTypeCompliance string = "compliance"

	// NasApplicationComponentsItems0SnaplockSnaplockTypeEnterprise captures enum value "enterprise"
	NasApplicationComponentsItems0SnaplockSnaplockTypeEnterprise string = "enterprise"

	// NasApplicationComponentsItems0SnaplockSnaplockTypeNonSnaplock captures enum value "non_snaplock"
	NasApplicationComponentsItems0SnaplockSnaplockTypeNonSnaplock string = "non_snaplock"
)

// prop value enum
func (m *NasApplicationComponentsItems0Snaplock) validateSnaplockTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0SnaplockTypeSnaplockTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0Snaplock) validateSnaplockType(formats strfmt.Registry) error {
	if swag.IsZero(m.SnaplockType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSnaplockTypeEnum("snaplock"+"."+"snaplock_type", "body", m.SnaplockType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nas application components items0 snaplock based on the context it is used
func (m *NasApplicationComponentsItems0Snaplock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Snaplock) contextValidateRetention(ctx context.Context, formats strfmt.Registry) error {

	if m.Retention != nil {

		if swag.IsZero(m.Retention) { // not required
			return nil
		}

		if err := m.Retention.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock" + "." + "retention")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snaplock" + "." + "retention")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Snaplock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Snaplock) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0Snaplock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0SnaplockRetention nas application components items0 snaplock retention
//
// swagger:model NasApplicationComponentsItems0SnaplockRetention
type NasApplicationComponentsItems0SnaplockRetention struct {

	// Specifies the default retention period that is applied to files while committing them to the WORM state without an associated retention period. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as quot;Plt;num&gt;Y&quot;, &quot;P&lt;num&gt;M&quot;, &quot;P&lt;num&gt;D&quot; respectively, for example &quot;P10Y&quot; represents a duration of 10 years. A duration in hours and minutes is represented by &quot;PT&lt;num&gt;H&quot; and &quot;PT&lt;num&gt;M&quot; respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example &quot;P1Y10M&quot; is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string &quot;infinite&quot; to set an infinite retention period and the string &quot;unspecified&quot; to set an unspecified retention period.
	Default string `json:"default,omitempty" yaml:"default,omitempty"`

	// Specifies the maximum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as &quot;P&lt;num&gt;Y&quot;, &quot;P&lt;num&gt;M&quot;, &quot;P&lt;num&gt;D&quot; respectively, for example &quot;P10Y&quot; represents a duration of 10 years. A duration in hours and minutes is represented by &quot;PT&lt;num&gt;H&quot; and &quot;PT&lt;num&gt;M&quot; respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example &quot;P1Y10M&quot; is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string &quot;infinite&quot; to set an infinite retention period.
	Maximum string `json:"maximum,omitempty" yaml:"maximum,omitempty"`

	// Specifies the minimum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, month,s and days is represented in the ISO-8601 format as &quot;P&lt;num&gt;Y&quot;, &quot;P&lt;num&gt;M&quot;, &quot;P&lt;num&gt;D&quot; respectively, for example &quot;P10Y&quot; represents a duration of 10 years. A duration in hours and minutes is represented by &quot;PT&lt;num&gt;H&quot; and &quot;PT&lt;num&gt;M&quot; respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example &quot;P1Y10M&quot; is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string &quot;infinite&quot; to set an infinite retention period.
	Minimum string `json:"minimum,omitempty" yaml:"minimum,omitempty"`
}

// Validate validates this nas application components items0 snaplock retention
func (m *NasApplicationComponentsItems0SnaplockRetention) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nas application components items0 snaplock retention based on context it is used
func (m *NasApplicationComponentsItems0SnaplockRetention) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0SnaplockRetention) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0SnaplockRetention) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0SnaplockRetention
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0StorageService nas application components items0 storage service
//
// swagger:model NasApplicationComponentsItems0StorageService
type NasApplicationComponentsItems0StorageService struct {

	// The storage service of the application component.
	// Enum: ["extreme","performance","value"]
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// Validate validates this nas application components items0 storage service
func (m *NasApplicationComponentsItems0StorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasApplicationComponentsItems0StorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0StorageServiceTypeNamePropEnum = append(nasApplicationComponentsItems0StorageServiceTypeNamePropEnum, v)
	}
}

const (

	// NasApplicationComponentsItems0StorageServiceNameExtreme captures enum value "extreme"
	NasApplicationComponentsItems0StorageServiceNameExtreme string = "extreme"

	// NasApplicationComponentsItems0StorageServiceNamePerformance captures enum value "performance"
	NasApplicationComponentsItems0StorageServiceNamePerformance string = "performance"

	// NasApplicationComponentsItems0StorageServiceNameValue captures enum value "value"
	NasApplicationComponentsItems0StorageServiceNameValue string = "value"
)

// prop value enum
func (m *NasApplicationComponentsItems0StorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0StorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0StorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 storage service based on context it is used
func (m *NasApplicationComponentsItems0StorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0StorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0StorageService) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0StorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasExcludeAggregatesItems0 nas exclude aggregates items0
//
// swagger:model NasExcludeAggregatesItems0
type NasExcludeAggregatesItems0 struct {

	// The name of the aggregate to exclude.
	// Enum: ["aggr0_fel_wps1_i01_r03a250_a_01","aggr0_fel_wps1_i01_r03a250_a_02","aggr0_fel_wps1_i01_r03a250_b_01","aggr0_fel_wps1_i01_r03a250_b_02","aggr_fel_wps1_i01_r03a250_a_01","aggr_fel_wps1_i01_r03a250_a_02","aggr_fel_wps1_i01_r03a250_b_01","aggr_fel_wps1_i01_r03a250_b_02"]
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// The ID of the aggregate to exclude. Usage: &lt;UUID&gt;
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// Validate validates this nas exclude aggregates items0
func (m *NasExcludeAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasExcludeAggregatesItems0TypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aggr0_fel_wps1_i01_r03a250_a_01","aggr0_fel_wps1_i01_r03a250_a_02","aggr0_fel_wps1_i01_r03a250_b_01","aggr0_fel_wps1_i01_r03a250_b_02","aggr_fel_wps1_i01_r03a250_a_01","aggr_fel_wps1_i01_r03a250_a_02","aggr_fel_wps1_i01_r03a250_b_01","aggr_fel_wps1_i01_r03a250_b_02"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasExcludeAggregatesItems0TypeNamePropEnum = append(nasExcludeAggregatesItems0TypeNamePropEnum, v)
	}
}

const (

	// NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250a01 captures enum value "aggr0_fel_wps1_i01_r03a250_a_01"
	NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250a01 string = "aggr0_fel_wps1_i01_r03a250_a_01"

	// NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250a02 captures enum value "aggr0_fel_wps1_i01_r03a250_a_02"
	NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250a02 string = "aggr0_fel_wps1_i01_r03a250_a_02"

	// NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250b01 captures enum value "aggr0_fel_wps1_i01_r03a250_b_01"
	NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250b01 string = "aggr0_fel_wps1_i01_r03a250_b_01"

	// NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250b02 captures enum value "aggr0_fel_wps1_i01_r03a250_b_02"
	NasExcludeAggregatesItems0NameAggr0FelWps1I01R03a250b02 string = "aggr0_fel_wps1_i01_r03a250_b_02"

	// NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250a01 captures enum value "aggr_fel_wps1_i01_r03a250_a_01"
	NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250a01 string = "aggr_fel_wps1_i01_r03a250_a_01"

	// NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250a02 captures enum value "aggr_fel_wps1_i01_r03a250_a_02"
	NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250a02 string = "aggr_fel_wps1_i01_r03a250_a_02"

	// NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250b01 captures enum value "aggr_fel_wps1_i01_r03a250_b_01"
	NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250b01 string = "aggr_fel_wps1_i01_r03a250_b_01"

	// NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250b02 captures enum value "aggr_fel_wps1_i01_r03a250_b_02"
	NasExcludeAggregatesItems0NameAggrFelWps1I01R03a250b02 string = "aggr_fel_wps1_i01_r03a250_b_02"
)

// prop value enum
func (m *NasExcludeAggregatesItems0) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasExcludeAggregatesItems0TypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasExcludeAggregatesItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas exclude aggregates items0 based on context it is used
func (m *NasExcludeAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasExcludeAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasExcludeAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res NasExcludeAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasProtectionType nas protection type
//
// swagger:model NasProtectionType
type NasProtectionType struct {

	// The Snapshot copy policy to apply to each volume in the smart container. This property is only supported for smart containers. Usage: &lt;snapshot policy&gt;
	LocalPolicy string `json:"local_policy,omitempty" yaml:"local_policy,omitempty"`

	// The local RPO of the application.
	// Enum: ["hourly","none"]
	LocalRpo string `json:"local_rpo,omitempty" yaml:"local_rpo,omitempty"`

	// The remote RPO of the application.
	// Enum: ["none","zero"]
	RemoteRpo string `json:"remote_rpo,omitempty" yaml:"remote_rpo,omitempty"`
}

// Validate validates this nas protection type
func (m *NasProtectionType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocalRpo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteRpo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasProtectionTypeTypeLocalRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasProtectionTypeTypeLocalRpoPropEnum = append(nasProtectionTypeTypeLocalRpoPropEnum, v)
	}
}

const (

	// NasProtectionTypeLocalRpoHourly captures enum value "hourly"
	NasProtectionTypeLocalRpoHourly string = "hourly"

	// NasProtectionTypeLocalRpoNone captures enum value "none"
	NasProtectionTypeLocalRpoNone string = "none"
)

// prop value enum
func (m *NasProtectionType) validateLocalRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasProtectionTypeTypeLocalRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasProtectionType) validateLocalRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocalRpoEnum("protection_type"+"."+"local_rpo", "body", m.LocalRpo); err != nil {
		return err
	}

	return nil
}

var nasProtectionTypeTypeRemoteRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasProtectionTypeTypeRemoteRpoPropEnum = append(nasProtectionTypeTypeRemoteRpoPropEnum, v)
	}
}

const (

	// NasProtectionTypeRemoteRpoNone captures enum value "none"
	NasProtectionTypeRemoteRpoNone string = "none"

	// NasProtectionTypeRemoteRpoZero captures enum value "zero"
	NasProtectionTypeRemoteRpoZero string = "zero"
)

// prop value enum
func (m *NasProtectionType) validateRemoteRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasProtectionTypeTypeRemoteRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasProtectionType) validateRemoteRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemoteRpoEnum("protection_type"+"."+"remote_rpo", "body", m.RemoteRpo); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas protection type based on context it is used
func (m *NasProtectionType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasProtectionType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasProtectionType) UnmarshalBinary(b []byte) error {
	var res NasProtectionType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
